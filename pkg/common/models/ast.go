package models

import (
	"fmt"
	"reflect"
	"txtracker/pkg/logger"
)

type ASTNode interface {
	Describe() string
	AddChild(child *Common)
	SetParent(parent *Common)
	Instace() *Common
	Attributes
}

type Attributes interface {
	Attributes() map[string]interface{}
	Constructor(*map[string]interface{})
}

// ast.go: corresponds to the AST JSON file generated by the Solidity compiler.
type Common struct {
	NodeType string `json:"nodeType"`
	Src      string `json:"src"` // location in the source code
	ID       int    `json:"id"`
	Parent   *Common
	Children []*Common //refactor here
}

func (c *Common) Describe() string {
	return fmt.Sprintf("This is a %s node.", c.NodeType)
}

func (c *Common) AddChild(child *Common) {
	c.Children = append(c.Children, child)
}

func (c *Common) SetParent(parent *Common) {
	c.Parent = parent
}

func (c *Common) Instace() *Common {
	return c
}

// Constructor------------------------------------------------------
func Reflect_constructor(dest *ASTNode, data *map[string]interface{}) {
	v := reflect.ValueOf(&dest).Elem()
	if v.Kind() != reflect.Ptr || v.IsNil() {
		logger.Fatal.Fatalf("Not a pointer: %v", v.Kind())
		panic("Reflect failed: not a pointer")
	}

	v = v.Elem() // &

	t := v.Type().String()
	fmt.Println("Type:", t)

	// t := v.Type()
	// for i := 0; i < t.NumField(); i++ {
	// 	jsonTag := t.Field(i).Tag.Get("json")

	// 	if value, ok := (*data)[jsonTag]; ok {
	// 		fieldValue := v.Field(i)
	// 		if fieldValue.IsValid() && fieldValue.CanSet() {
	// 			switch fieldValue.Kind() {
	// 			case reflect.String:
	// 				fieldValue.SetString(value.(string))
	// 			case reflect.Map:
	// 				fieldValue.Set(reflect.ValueOf(value))
	// 			}
	// 		}
	// 	}
	// }
}

// Top-level node for a .sol file
type SourceUnit struct {
	Common
	AbsolutePath    string         `json:"absolutePath"`
	ExportedSymbols map[string]int `json:"exportedSymbols"`
}

func (s *SourceUnit) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"AbsolutePath":    s.AbsolutePath,
		"ExportedSymbols": s.ExportedSymbols,
	}
}

// ----------------------------------------------------------------------------
// Compiler version node
type PragmaDirective struct {
	Common
	Literals []string `json:"literals"`
}

func (p *PragmaDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Literals": p.Literals,
	}
}

// ----------------------------------------------------------------------------
// ContractDefinition
type ContractDefinition struct {
	Common
	Name                     string                 `json:"name"`
	BaseContracts            []InheritanceSpecifier `json:"baseContracts"` //?
	ContractDependenceies    []string               `json:"contractDependencies"`
	LinearizaedBaseContracts []string               `json:"linearizedBaseContracts"`
	SubNodes                 []Common               `json:"nodes"` //?
	ContractKind             string                 `json:"contractKind"`
}

func (c *ContractDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":                     c.Name,
		"BaseContracts":            c.BaseContracts,
		"ContractDependenceies":    c.ContractDependenceies,
		"LinearizaedBaseContracts": c.LinearizaedBaseContracts,
		"SubNodes":                 c.SubNodes,
		"ContractKind":             c.ContractKind,
	}
}

// ----------------------------------------------------------------------------
// Block node, which contains a list of statements between '{' and '}'
type Block struct {
	Common
	Statements []ExpressionStatement `json:"statements"`
}

func (b *Block) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Statements": b.Statements,
	}
}

// ----------------------------------------------------------------------------
// Identifier node
type Identifier struct {
	Common
	ArgumentTypes          []string         `json:"argumentTypes"`
	OverloadedDeclarations []string         `json:"overloadedDeclarations"`
	ReferencedDeclaration  int              `json:"referencedDeclaration"`
	TypeDescriptions       TypeDescriptions `json:"typeDescriptions"`
}

func (i *Identifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":          i.ArgumentTypes,
		"OverloadedDeclarations": i.OverloadedDeclarations,
		"ReferencedDeclaration":  i.ReferencedDeclaration,
		"TypeDescriptions":       i.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// TypeDescriptions node
type TypeDescriptions struct {
	Common
	TypeString     string `json:"typeString"`
	TypeIdentifier string `json:"typeIdentifier"`
}

func (t *TypeDescriptions) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"TypeString":     t.TypeString,
		"TypeIdentifier": t.TypeIdentifier,
	}
}

// ----------------------------------------------------------------------------
// BinaryOperation node
type BinaryOperation struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	CommonType       TypeDescriptions `json:"commonType"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	LeftExpression   Common           `json:"leftExpression"`
	Operator         string           `json:"operator"`
	RightExpression  Common           `json:"rightExpression"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (b *BinaryOperation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    b.ArgumentTypes,
		"CommonType":       b.CommonType,
		"IsConstant":       b.IsConstant,
		"IsLValue":         b.IsLValue,
		"IsPure":           b.IsPure,
		"LValueRequested":  b.LValueRequested,
		"LeftExpression":   b.LeftExpression,
		"Operator":         b.Operator,
		"RightExpression":  b.RightExpression,
		"TypeDescriptions": b.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// Literal node
type Literal struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	HexValue         string           `json:"hexValue"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	Kind             string           `json:"kind"`
	LValueRequested  bool             `json:"lValueRequested"`
	Subdenomination  string           `json:"subdenomination"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	Value            string           `json:"value"`
}

func (l *Literal) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    l.ArgumentTypes,
		"HexValue":         l.HexValue,
		"IsConstant":       l.IsConstant,
		"IsLValue":         l.IsLValue,
		"IsPure":           l.IsPure,
		"Kind":             l.Kind,
		"LValueRequested":  l.LValueRequested,
		"Subdenomination":  l.Subdenomination,
		"TypeDescriptions": l.TypeDescriptions,
		"Value":            l.Value,
	}
}

// ----------------------------------------------------------------------------
// IfStatement node
type IfStatement struct {
	Common
	Condition BinaryOperation `json:"condition"`
	FalseBody Block           `json:"falseBody"`
	TrueBody  Block           `json:"trueBody"`
}

func (i *IfStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Condition": i.Condition,
		"FalseBody": i.FalseBody,
		"TrueBody":  i.TrueBody,
	}
}

// ----------------------------------------------------------------------------
// Return node
type Return struct {
	Common
	Expression               Common `json:"expression"`
	FunctionReturnParameters int    `json:"functionReturnParameters"`
}

func (r *Return) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Expression":               r.Expression,
		"FunctionReturnParameters": r.FunctionReturnParameters,
	}
}

// ----------------------------------------------------------------------------
// VariableDeclaration node
type VariableDeclaration struct {
	Common
	Constant         bool               `json:"constant"`
	Name             string             `json:"name"`
	Scope            int                `json:"scope"`
	StateVariable    bool               `json:"stateVariable"`
	StorageLocation  string             `json:"storageLocation"`
	TypeDescriptions TypeDescriptions   `json:"typeDescriptions"`
	TypeName         ElementaryTypeName `json:"typeName"`
	Value            Common             `json:"value"`
	Visibility       string             `json:"visibility"`
}

func (v *VariableDeclaration) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Constant":         v.Constant,
		"Name":             v.Name,
		"Scope":            v.Scope,
		"StateVariable":    v.StateVariable,
		"StorageLocation":  v.StorageLocation,
		"TypeDescriptions": v.TypeDescriptions,
		"TypeName":         v.TypeName,
		"Value":            v.Value,
		"Visibility":       v.Visibility,
	}
}

// ----------------------------------------------------------------------------
// ElementaryTypeName node

type ElementaryTypeName struct {
	Common
	Name             string           `json:"name"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (e *ElementaryTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":             e.Name,
		"TypeDescriptions": e.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// VariableDeclarationStatement node

type VariableDeclarationStatement struct {
	Common
	Assignments   []int                 `json:"assignments"`
	Declarrations []VariableDeclaration `json:"declarations"`
	InitialValue  Common                `json:"initialValue"`
}

func (v *VariableDeclarationStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Assignments":   v.Assignments,
		"Declarrations": v.Declarrations,
		"InitialValue":  v.InitialValue,
	}
}

// ----------------------------------------------------------------------------
// FunctionCall node
type FunctionCall struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	Arguments        []Common         `json:"arguments"`
	Expression       Common           `json:"expression"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	Kind             string           `json:"kind"`
	LValueRequested  bool             `json:"lValueRequested"`
	Names            []string         `json:"names"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (f *FunctionCall) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    f.ArgumentTypes,
		"Arguments":        f.Arguments,
		"Expression":       f.Expression,
		"IsConstant":       f.IsConstant,
		"IsLValue":         f.IsLValue,
		"IsPure":           f.IsPure,
		"Kind":             f.Kind,
		"LValueRequested":  f.LValueRequested,
		"Names":            f.Names,
		"TypeDescriptions": f.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// ExpressionStatement node
type ExpressionStatement struct {
	Common
	Expression Common `json:"expression"`
}

func (e *ExpressionStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Expression": e.Expression,
	}
}

// ----------------------------------------------------------------------------
// FunctionDefinition node
type FunctionDefinition struct {
	Common
	Implemented      bool          `json:"implemented"`
	IsConstructor    bool          `json:"isConstructor"`
	IsDeclaredConst  bool          `json:"isDeclaredConst"`
	Modifiers        []Common      `json:"modifiers"`
	Name             string        `json:"name"`
	Parameters       ParameterList `json:"parameters"`
	Payable          bool          `json:"payable"`
	ReturnParameters ParameterList `json:"returnParameters"`
	Scope            int           `json:"scope"`
	StateMutability  string        `json:"stateMutability"`
	SuperFunction    string        `json:"superFunction"`
	Visibility       string        `json:"visibility"`
}

func (f *FunctionDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Implemented":      f.Implemented,
		"IsConstructor":    f.IsConstructor,
		"IsDeclaredConst":  f.IsDeclaredConst,
		"Modifiers":        f.Modifiers,
		"Name":             f.Name,
		"Parameters":       f.Parameters,
		"Payable":          f.Payable,
		"ReturnParameters": f.ReturnParameters,
		"Scope":            f.Scope,
		"StateMutability":  f.StateMutability,
		"SuperFunction":    f.SuperFunction,
		"Visibility":       f.Visibility,
	}
}

// ----------------------------------------------------------------------------
// ParameterList node
type ParameterList struct {
	Common
	Parameters []Common `json:"parameters"`
}

func (p *ParameterList) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Parameters": p.Parameters,
	}
}

// ----------------------------------------------------------------------------
// EventDefinition node
type EventDefinition struct {
	Common
	Anonymous  bool          `json:"anonymous"`
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
}

func (e *EventDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Anonymous":  e.Anonymous,
		"Name":       e.Name,
		"Parameters": e.Parameters,
	}
}

// ----------------------------------------------------------------------------
// Assignment node
type Assignment struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	LeftHandSide     Common           `json:"leftHandSide"`
	Operator         string           `json:"operator"`
	RightHandSide    Common           `json:"rightHandSide"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (a *Assignment) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    a.ArgumentTypes,
		"IsConstant":       a.IsConstant,
		"IsLValue":         a.IsLValue,
		"IsPure":           a.IsPure,
		"LValueRequested":  a.LValueRequested,
		"LeftHandSide":     a.LeftHandSide,
		"Operator":         a.Operator,
		"RightHandSide":    a.RightHandSide,
		"TypeDescriptions": a.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// MemberAccess node
type MemberAccess struct {
	Common
	ArgumentTypes         []string         `json:"argumentTypes"`
	Expression            Common           `json:"expression"`
	IsConstant            bool             `json:"isConstant"`
	IsLValue              bool             `json:"isLValue"`
	IsPure                bool             `json:"isPure"`
	LValueRequested       bool             `json:"lValueRequested"`
	MemberName            string           `json:"memberName"`
	ReferencedDeclaration int              `json:"referencedDeclaration"`
	TypeDescriptions      TypeDescriptions `json:"typeDescriptions"`
}

func (m *MemberAccess) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":         m.ArgumentTypes,
		"Expression":            m.Expression,
		"IsConstant":            m.IsConstant,
		"IsLValue":              m.IsLValue,
		"IsPure":                m.IsPure,
		"LValueRequested":       m.LValueRequested,
		"MemberName":            m.MemberName,
		"ReferencedDeclaration": m.ReferencedDeclaration,
		"TypeDescriptions":      m.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// PlacehoderStatement node
type PlacehoderStatement struct {
	Common
}

func (p *PlacehoderStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{}
}

// ----------------------------------------------------------------------------
// ModifierDefinition node
type ModifierDefinition struct {
	Common
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
	Visibility string        `json:"visibility"`
}

func (m *ModifierDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":       m.Name,
		"Parameters": m.Parameters,
		"Visibility": m.Visibility,
	}
}

// ----------------------------------------------------------------------------
// ElementaryTypeNameExpression node
type ElementaryTypeNameExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	TypeName         string           `json:"typeName"`
}

func (e *ElementaryTypeNameExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    e.ArgumentTypes,
		"IsConstant":       e.IsConstant,
		"IsLValue":         e.IsLValue,
		"IsPure":           e.IsPure,
		"LValueRequested":  e.LValueRequested,
		"TypeDescriptions": e.TypeDescriptions,
		"TypeName":         e.TypeName,
	}
}

// ----------------------------------------------------------------------------
// ModifierInvocation node
type ModifierInvocation struct {
	Common
	Arguments    []Common `json:"arguments"`
	ModifierName Common   `json:"modifierName"`
}

func (m *ModifierInvocation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments":    m.Arguments,
		"ModifierName": m.ModifierName,
	}
}

// ----------------------------------------------------------------------------
// UserDefinedTypeName node
type UserDefinedTypeName struct {
	Common
	ContractScope        string           `json:"contractScope"`
	ReferenceDeclaration int              `json:"referencedDeclaration"`
	TypeDescriptions     TypeDescriptions `json:"typeDescriptions"`
}

func (u *UserDefinedTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ContractScope":        u.ContractScope,
		"ReferenceDeclaration": u.ReferenceDeclaration,
		"TypeDescriptions":     u.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// InheritanceSpecifier node
type InheritanceSpecifier struct {
	Common
	Arguments []Common `json:"arguments"`
	BaseName  Common   `json:"baseName"`
}

func (i *InheritanceSpecifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments": i.Arguments,
		"BaseName":  i.BaseName,
	}
}

// ----------------------------------------------------------------------------
// UnaryOperation node
type UnaryOperation struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	Operator         string           `json:"operator"`
	Prefix           bool             `json:"prefix"`
	SubExpression    Common           `json:"subExpression"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (u *UnaryOperation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    u.ArgumentTypes,
		"IsConstant":       u.IsConstant,
		"IsLValue":         u.IsLValue,
		"IsPure":           u.IsPure,
		"LValueRequested":  u.LValueRequested,
		"Operator":         u.Operator,
		"Prefix":           u.Prefix,
		"SubExpression":    u.SubExpression,
		"TypeDescriptions": u.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// Mapping node
type Mapping struct {
	Common
	KeyType          Common           `json:"keyType"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	ValueType        Common           `json:"valueType"`
}

func (m *Mapping) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"KeyType":          m.KeyType,
		"TypeDescriptions": m.TypeDescriptions,
		"ValueType":        m.ValueType,
	}
}

// ----------------------------------------------------------------------------
// StructDefinition node
type StructDefinition struct {
	Common
	CanonicalName string   `json:"canonicalName"`
	Members       []Common `json:"members"`
	Name          string   `json:"name"`
	Scope         int      `json:"scope"`
	Visibility    string   `json:"visibility"`
}

func (s *StructDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": s.CanonicalName,
		"Members":       s.Members,
		"Name":          s.Name,
		"Scope":         s.Scope,
		"Visibility":    s.Visibility,
	}
}

// ----------------------------------------------------------------------------
// UsingForDirective node
type UsingForDirective struct {
	Common
	LibraryName Common `json:"libraryName"`
	TypeName    Common `json:"typeName"`
}

func (u *UsingForDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"LibraryName": u.LibraryName,
		"TypeName":    u.TypeName,
	}
}

// ----------------------------------------------------------------------------
// IndexAccess node
type IndexAccess struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	BaseExpression   []Common         `json:"baseExpression"`
	IndexExpression  []Common         `json:"indexExpression"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (i *IndexAccess) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    i.ArgumentTypes,
		"BaseExpression":   i.BaseExpression,
		"IndexExpression":  i.IndexExpression,
		"IsConstant":       i.IsConstant,
		"IsLValue":         i.IsLValue,
		"IsPure":           i.IsPure,
		"LValueRequested":  i.LValueRequested,
		"TypeDescriptions": i.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// EnumValue node
type EnumValue struct {
	Common
	Name string `json:"name"`
}

func (e *EnumValue) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name": e.Name,
	}
}

// ----------------------------------------------------------------------------
// EnumDefinition node
type EnumDefinition struct {
	Common
	CanonicalName string      `json:"canonicalName"`
	Members       []EnumValue `json:"members"`
	Name          string      `json:"name"`
}

func (e *EnumDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": e.CanonicalName,
		"Members":       e.Members,
		"Name":          e.Name,
	}
}

// ----------------------------------------------------------------------------
// ArraryTypeName node
type ArraryTypeName struct {
	Common
	BaseType         Common           `json:"baseType"`
	Length           string           `json:"length"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (a *ArraryTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"BaseType":         a.BaseType,
		"Length":           a.Length,
		"TypeDescriptions": a.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// ForStatement node
type ForStatement struct {
	Common
	Body                     Block           `json:"body"`
	Condition                BinaryOperation `json:"condition"`
	InitializationExpression Common          `json:"initializationExpression"`
	LoopExpression           Common          `json:"loopExpression"`
}

func (f *ForStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Body":                     f.Body,
		"Condition":                f.Condition,
		"InitializationExpression": f.InitializationExpression,
		"LoopExpression":           f.LoopExpression,
	}
}

// ----------------------------------------------------------------------------
// Break node
type Break struct {
	Common
}

func (b *Break) Attributes() map[string]interface{} {
	return map[string]interface{}{}
}

// ----------------------------------------------------------------------------
// TupleExpression node
type TupleExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	Components       []Common         `json:"components"`
	IsConstant       bool             `json:"isConstant"`
	IsInlineArray    bool             `json:"isInlineArray"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (t *TupleExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    t.ArgumentTypes,
		"Components":       t.Components,
		"IsConstant":       t.IsConstant,
		"IsInlineArray":    t.IsInlineArray,
		"IsLValue":         t.IsLValue,
		"IsPure":           t.IsPure,
		"LValueRequested":  t.LValueRequested,
		"TypeDescriptions": t.TypeDescriptions,
	}
}

// ----------------------------------------------------------------------------
// NewExpression node
type NewExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	TypeName         Common           `json:"typeName"`
}

func (n *NewExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    n.ArgumentTypes,
		"IsConstant":       n.IsConstant,
		"IsLValue":         n.IsLValue,
		"IsPure":           n.IsPure,
		"LValueRequested":  n.LValueRequested,
		"TypeDescriptions": n.TypeDescriptions,
		"TypeName":         n.TypeName,
	}
}

// ----------------------------------------------------------------------------
// Helper function to convert a map[string]interface{} to an ASTNode

func StringToASTNode(data map[string]interface{}) (ASTNode, error) {
	//nodeType string, src string, id int

	nodeType, ok := data["nodeType"].(string)
	if !ok || nodeType == "" {
		return nil, fmt.Errorf("nodeType not found")
	}

	src := data["src"].(string)
	if !ok || src == "" {
		return nil, fmt.Errorf("src not found")
	}

	id := int(data["id"].(float64))
	if !ok || id == 0 {
		return nil, fmt.Errorf("id not found or id is 0")
	}

	switch nodeType {
	case "SourceUnit":
		return &SourceUnit{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PragmaDirective":
		return &PragmaDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ContractDefinition":
		return &ContractDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Block":
		return &Block{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Identifier":
		return &Identifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TypeDescriptions":
		return &TypeDescriptions{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "BinaryOperation":
		return &BinaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Literal":
		return &Literal{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IfStatement":
		return &IfStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Return":
		return &Return{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclaration":
		return &VariableDeclaration{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeName":
		return &ElementaryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclarationStatement":
		return &VariableDeclarationStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionCall":
		return &FunctionCall{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ExpressionStatement":
		return &ExpressionStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionDefinition":
		return &FunctionDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ParameterList":
		return &ParameterList{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EventDefinition":
		return &EventDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Assignment":
		return &Assignment{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "MemberAccess":
		return &MemberAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PlacehoderStatement":
		return &PlacehoderStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierDefinition":
		return &ModifierDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeNameExpression":
		return &ElementaryTypeNameExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierInvocation":
		return &ModifierInvocation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UserDefinedTypeName":
		return &UserDefinedTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "InheritanceSpecifier":
		return &InheritanceSpecifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UnaryOperation":
		return &UnaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Mapping":
		return &Mapping{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "StructDefinition":
		return &StructDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UsingForDirective":
		return &UsingForDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IndexAccess":
		return &IndexAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumValue":
		return &EnumValue{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumDefinition":
		return &EnumDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ArraryTypeName":
		return &ArraryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ForStatement":
		return &ForStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Break":
		return &Break{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TupleExpression":
		return &TupleExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "NewExpression":
		return &NewExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil

	default:
		return nil, fmt.Errorf("nodeType %s not found", nodeType)
	}
}
