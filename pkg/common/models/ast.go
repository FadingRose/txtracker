package models

import (
	"fmt"
	"txtracker/pkg/logger"
)

type ASTNode interface {
	Describe() string
	AddChild(child *Common)
	SetParent(parent *Common)
	Instance() *Common
	Attributes
}

type Attributes interface {
	Attributes() map[string]interface{}
	Constructor(*map[string]interface{})
}

// `Mutabilityâ€œ:
// "mutable" | "immutable" | "constant"
type Mutability string

const (
	Mutable   Mutability = "mutable"
	Immutable Mutability = "immutable"
	Constant  Mutability = "constant"
)

// `ContractKind`: "contract" | "interface" | "library"
type ContractKind string

const (
	ContractKind_Contract  ContractKind = "contract"
	ContractKind_Interface ContractKind = "interface"
	ContractKind_Library   ContractKind = "library"
)

// `SourceLocation`: string
type SourceLocation string

// `StorageLocation`: "default" | "memory" | "storage" | "calldata"
type StorageLocation string

const (
	Default  StorageLocation = "default"
	Memory   StorageLocation = "memory"
	Storage  StorageLocation = "storage"
	CallData StorageLocation = "calldata"
)

type FunctionDefinitionKind string

const (
	FunctionDefinitionKindFunction     FunctionDefinitionKind = "function"
	FunctionDefinitionKindConstructor  FunctionDefinitionKind = "constructor"
	FunctionDefinitionKindFallback     FunctionDefinitionKind = "fallback"
	FunctionDefinitionKindReceive      FunctionDefinitionKind = "receive"
	FunctionDefinitionKindFreeFunction FunctionDefinitionKind = "free"
)

// ast.go: corresponds to the AST JSON file generated by the Solidity compiler.
type Common struct {
	NodeType string `json:"nodeType"`
	Src      string `json:"src"` // location in the source code
	ID       int    `json:"id"`
	Parent   *Common
	Children []*Common //refactor here
}

func (c *Common) Describe() string {
	return fmt.Sprintf("This is a %s node.", c.NodeType)
}

func (c *Common) AddChild(child *Common) {
	c.Children = append(c.Children, child)
}

func (c *Common) SetParent(parent *Common) {
	c.Parent = parent
}

func (c *Common) Instance() *Common {
	return c
}

// Top-level node for a .sol file
type SourceUnit struct {
	Common
	AbsolutePath    string         `json:"absolutePath"`
	ExportedSymbols map[string]int `json:"exportedSymbols"` // 'symboleName': 'nodeId
}

func (s *SourceUnit) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"AbsolutePath":    s.AbsolutePath,
		"ExportedSymbols": s.ExportedSymbols,
	}
}

func (s *SourceUnit) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["absolutePath"]; ok {
		s.AbsolutePath = value.(string)
	}
	if value, ok := (*data)["exportedSymbols"]; ok {
		var res = make(map[string]int)
		value := value.(map[string]interface{})
		for key, val := range value {
			v := val.([]interface{})[0].(float64)
			res[key] = int(v)
		}
		s.ExportedSymbols = res
	}

}

// ----------------------------------------------------------------------------
// Compiler version node
type PragmaDirective struct {
	Common
	Literals []string `json:"literals"`
}

func (p *PragmaDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Literals": p.Literals,
	}
}

func (p *PragmaDirective) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["literals"]; ok {
		var res = make([]string, 0)
		for _, v := range value.([]interface{}) {
			res = append(res, v.(string))
		}
		p.Literals = res
	}
}

// ----------------------------------------------------------------------------
// ContractDefinition
type ContractDefinition struct {
	Common
	Abstract                bool                   `json:"abstract"`
	BaseContracts           []InheritanceSpecifier `json:"baseContracts"`
	CanonicalName           string                 `json:"canonicalName"` // string | null
	ContractDependenceies   []int                  `json:"contractDependencies"`
	ContractKind            ContractKind           `json:"contractKind"`
	FullyImplemented        bool                   `json:"fullyImplemented"`
	InternalFuntiionIDs     map[string]int         `json:"internalFunctionIDs"` // 'functionName': 'nodeId' | null
	LinearizedBaseContracts []int                  `json:"linearizedBaseContracts"`
	Name                    string                 `json:"name"`
	NameLocation            string                 `json:"nameLocation"` // string | null
	Scope                   int                    `json:"scope"`
	UsedErrors              []int                  `json:"usedErrors"`
	UsedEvents              []int                  `json:"usedEvents"`
}

func (c *ContractDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Abstract":                c.Abstract,
		"BaseContracts":           c.BaseContracts,
		"CanonicalName":           c.CanonicalName,
		"ContractDependenceies":   c.ContractDependenceies,
		"ContractKind":            c.ContractKind,
		"FullyImplemented":        c.FullyImplemented,
		"InternalFuntiionIDs":     c.InternalFuntiionIDs,
		"LinearizedBaseContracts": c.LinearizedBaseContracts,
		"Name":                    c.Name,
		"NameLocation":            c.NameLocation,
		"Scope":                   c.Scope,
		"UsedErrors":              c.UsedErrors,
		"UsedEvents":              c.UsedEvents,
	}
}

// TODO : Test the `baseContracts` is NOT empty
func (c *ContractDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["abstract"]; ok {
		c.Abstract = value.(bool)
	}
	if value, ok := (*data)["baseContracts"]; ok {
		if len(value.([]interface{})) == 0 {
			c.BaseContracts = []InheritanceSpecifier{}
		} else {
			var res = make([]InheritanceSpecifier, 0)
			for _, v := range value.([]interface{}) {
				v := v.(map[string]interface{})
				var inheritanceSpecifier InheritanceSpecifier
				inheritanceSpecifier.Constructor(&v)
				res = append(res, inheritanceSpecifier)
			}
			c.BaseContracts = res
		}

	}

	if value, ok := (*data)["canonicalName"]; ok { // string | null
		c.CanonicalName = value.(string)
	} else {
		c.CanonicalName = ""
	}

	if value, ok := (*data)["contractDependencies"]; ok {
		if len(value.([]interface{})) == 0 {
			c.ContractDependenceies = []int{}
		} else {
			var res = make([]int, 0)
			for _, v := range value.([]interface{}) {
				v := v.(float64)
				res = append(res, (int)(v))
			}
			c.ContractDependenceies = res
		}

	}

	if value, ok := (*data)["contractKind"]; ok {
		switch value.(string) {
		case "contract":
			c.ContractKind = ContractKind_Contract
		case "interface":
			c.ContractKind = ContractKind_Interface
		case "library":
			c.ContractKind = ContractKind_Library
		default:
			logger.Fatal.Println("Unknown contract kind:", value)
			panic("Unknown contract kind.")
		}
	}

	if value, ok := (*data)["fullyImplemented"]; ok {
		c.FullyImplemented = value.(bool)
	}

	if value, ok := (*data)["internalFunctionIDs"]; ok { // 'functionName': 'nodeId' | null
		var res = make(map[string]int)
		for key, val := range value.(map[string]interface{}) {
			v := val.(float64)
			res[key] = (int)(v)
		}
		c.InternalFuntiionIDs = res
	} else {
		c.InternalFuntiionIDs = nil
	}

	if value, ok := (*data)["linearizedBaseContracts"]; ok {
		var res = make([]int, 0)
		for _, v := range value.([]interface{}) {
			v := v.(float64)
			res = append(res, (int)(v))
		}
		c.LinearizedBaseContracts = res
	}

	if value, ok := (*data)["name"]; ok {
		c.Name = value.(string)
	}

	if value, ok := (*data)["nameLocation"]; ok { // string | null
		c.NameLocation = value.(string)
	} else {
		c.NameLocation = ""
	}

	if value, ok := (*data)["scope"]; ok {
		value := value.(float64)
		c.Scope = (int)(value)
	}

}

// ----------------------------------------------------------------------------
// TypeDescriptions node
type TypeDescriptions struct {
	Common
	TypeString     string `json:"typeString"`
	TypeIdentifier string `json:"typeIdentifier"`
}

func (t *TypeDescriptions) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"TypeString":     t.TypeString,
		"TypeIdentifier": t.TypeIdentifier,
	}
}

func (t *TypeDescriptions) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["typeString"]; ok {
		t.TypeString = value.(string)
	}
	if value, ok := (*data)["typeIdentifier"]; ok {
		t.TypeIdentifier = value.(string)
	}
}

// ----------------------------------------------------------------------------
// VariableDeclaration node
type VariableDeclaration struct {
	Common
	Constant         bool               `json:"constant"`
	Name             string             `json:"name"`
	Scope            int                `json:"scope"`
	StateVariable    bool               `json:"stateVariable"`
	StorageLocation  string             `json:"storageLocation"`
	TypeDescriptions TypeDescriptions   `json:"typeDescriptions"`
	TypeName         ElementaryTypeName `json:"typeName"`
	Value            Literal            `json:"value"`
	Visibility       string             `json:"visibility"`
}

func (v *VariableDeclaration) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Constant":         v.Constant,
		"Name":             v.Name,
		"Scope":            v.Scope,
		"StateVariable":    v.StateVariable,
		"StorageLocation":  v.StorageLocation,
		"TypeDescriptions": v.TypeDescriptions,
		"TypeName":         v.TypeName,
		"Value":            v.Value,
		"Visibility":       v.Visibility,
	}
}

func (v *VariableDeclaration) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["constant"]; ok {
		v.Constant = value.(bool)
	}
	if value, ok := (*data)["name"]; ok {
		v.Name = value.(string)
	}
	if value, ok := (*data)["scope"]; ok {
		v.Scope = (int)(value.(float64))
	}
	if value, ok := (*data)["stateVariable"]; ok {
		v.StateVariable = value.(bool)
	}
	if value, ok := (*data)["storageLocation"]; ok {
		v.StorageLocation = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		value := value.(map[string]interface{})
		var res TypeDescriptions
		res.Constructor(&value)
		v.TypeDescriptions = res
	}
	if value, ok := (*data)["typeName"]; ok {
		value := value.(map[string]interface{})
		var res ElementaryTypeName
		res.Constructor(&value)
		v.TypeName = res
	}
	if value, ok := (*data)["value"]; ok {
		var res Literal
		if value == nil {
			res = Literal{}
		} else {
			value := value.(map[string]interface{})
			res.Constructor(&value)
		}
		v.Value = res
	}
	if value, ok := (*data)["visibility"]; ok {
		v.Visibility = value.(string)
	}
}

func (v *VariableDeclaration) Describe() string {
	return fmt.Sprintf("This is a variable declaration.")
}

// ----------------------------------------------------------------------------
// FunctionDefinition node
// TODO Fix the attributes, check whether keys are satisfied.
type FunctionDefinition struct {
	Common
	BaseFunctions    []int                  `json:"baseFunctions"`    // 'nodeId' | null
	Body             Block                  `json:"body"`             // Block | null
	FunctionSelector string                 `json:"functionSelector"` // string | null
	Implemented      bool                   `json:"implemented"`
	Kind             FunctionDefinitionKind `json:"kind"`
	Modifiers        []ModifierInvocation   `json:"modifiers"`
	Name             string                 `json:"name"`
	NameLocation     string                 `json:"nameLocation"` // string | null
	Overrides        OverideSpecifier       `json:"overrides"`    // OverideSpecifier | null
	Parameters       ParameterList          `json:"parameters"`
	ReturnParameters ParameterList          `json:"returnParameters"`
	Scope            int                    `json:"scope"`
	StateMutability  StateMutability        `json:"stateMutability"`
	Virtual          bool                   `json:"virtual"`
	Visibility       Visibility             `json:"visibility"`
}

func (f *FunctionDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"BaseFunctions":    f.BaseFunctions,    // 'nodeId' | null
		"Body":             f.Body,             // Block | null
		"FunctionSelector": f.FunctionSelector, // string | null
		"Implemented":      f.Implemented,
		"Kind":             f.Kind,
		"Modifiers":        f.Modifiers,
		"Name":             f.Name,
		"NameLocation":     f.NameLocation, // string | null
		"Overrides":        f.Overrides,    // OverideSpecifier | null
		"Parameters":       f.Parameters,
		"ReturnParameters": f.ReturnParameters,
		"Scope":            f.Scope,
		"StateMutability":  f.StateMutability,
		"Virtual":          f.Virtual,
		"Visibility":       f.Visibility,
	}
}

func (f *FunctionDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["baseFunctions"]; ok {
		if len(value.([]interface{})) == 0 {
			f.BaseFunctions = []int{}
		} else {
			var res = make([]int, 0)
			for _, v := range value.([]interface{}) {
				v := v.(float64)
				res = append(res, (int)(v))
			}
			f.BaseFunctions = res
		}
	}
	if value, ok := (*data)["body"]; ok {
		value := value.(map[string]interface{})
		var res Block
		res.Constructor(&value)
		f.Body = res
	}
	if value, ok := (*data)["functionSelector"]; ok {
		f.FunctionSelector = value.(string)
	}
	if value, ok := (*data)["implemented"]; ok {
		f.Implemented = value.(bool)
	}
	if value, ok := (*data)["kind"]; ok {
		switch value.(string) {
		case "function":
			f.Kind = FunctionDefinitionKindFunction
		case "constructor":
			f.Kind = FunctionDefinitionKindConstructor
		case "fallback":
			f.Kind = FunctionDefinitionKindFallback
		case "receive":
			f.Kind = FunctionDefinitionKindReceive
		case "free":
			f.Kind = FunctionDefinitionKindFreeFunction
		default:
			logger.Fatal.Println("Unknown function kind:", value)
			panic("Unknown function kind.")
		}
	}
	if value, ok := (*data)["modifiers"]; ok {
		if len(value.([]interface{})) == 0 {
			f.Modifiers = make([]ModifierInvocation, 0)
		} else {
			var res = make([]ModifierInvocation, 0)
			for _, v := range value.([]interface{}) {
				v := v.(map[string]interface{})
				var modifierInvocation ModifierInvocation
				modifierInvocation.Constructor(&v)
				res = append(res, modifierInvocation)
			}
			f.Modifiers = res
		}
	}
	if value, ok := (*data)["name"]; ok {
		f.Name = value.(string)
	}
	if value, ok := (*data)["nameLocation"]; ok {
		f.NameLocation = value.(string)
	}
	if value, ok := (*data)["overrides"]; ok {
		value := value.(map[string]interface{})
		var res OverideSpecifier
		res.Constructor(&value)
		f.Overrides = res
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		f.Parameters = res
	}
	if value, ok := (*data)["returnParameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		f.ReturnParameters = res
	}
	if value, ok := (*data)["scope"]; ok {
		f.Scope = (int)(value.(float64))
	}
	if value, ok := (*data)["stateMutability"]; ok {
		switch value.(string) {
		case "pure":
			f.StateMutability = Pure
		case "view":
			f.StateMutability = View
		case "payable":
			f.StateMutability = Payable
		case "nonpayable":
			f.StateMutability = Nonpayable
		default:
			logger.Fatal.Println("Unknown state mutability:", value)
			panic("Unknown state mutability.")
		}
	}
	if value, ok := (*data)["virtual"]; ok {
		f.Virtual = value.(bool)
	}
	if value, ok := (*data)["visibility"]; ok {
		switch value.(string) {
		case "external":
			f.Visibility = External
		case "internal":
			f.Visibility = Internal
		case "private":
			f.Visibility = Private
		case "public":
			f.Visibility = Public
		default:
			logger.Fatal.Println("Unknown visibility:", value)
			panic("Unknown visibility.")
		}
	}

}

// ----------------------------------------------------------------------------
// OverrideSpecifier node
type OverrideSpecifiers interface {
	Constructor(*map[string]interface{})
	DescribeOverrideSpecifier() string
}

type OverideSpecifier struct {
	Common
	Overrides []OverrideSpecifiers `json:"overrides"` // []UserDefinedTypeName | []IdentifierPath
}

func (o *OverideSpecifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Overrides": o.Overrides,
	}
}

func (o *OverideSpecifier) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["overrides"]; ok {
		if len(value.([]interface{})) == 0 {
			o.Overrides = make([]OverrideSpecifiers, 0)
		} else {
			panic("Overrides is NOT empty.")
		}
	}
}

// ----------------------------------------------------------------------------
// ParameterList node
type ParameterList struct {
	Common
	Parameters []VariableDeclaration `json:"parameters"`
}

func (p *ParameterList) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Parameters": p.Parameters,
	}
}

func (p *ParameterList) Constructor(data *map[string]interface{}) {

	if value, ok := (*data)["parameters"]; ok {
		if len(value.([]interface{})) == 0 {
			p.Parameters = make([]VariableDeclaration, 0)
		} else {
			var res = make([]VariableDeclaration, 0)
			for _, v := range value.([]interface{}) {
				v := v.(map[string]interface{})
				var variableDeclaration VariableDeclaration
				variableDeclaration.Constructor(&v)
				res = append(res, variableDeclaration)
			}
			p.Parameters = res
		}
	}
}

// ----------------------------------------------------------------------------
// EventDefinition node
type EventDefinition struct {
	Common
	Anonymous  bool          `json:"anonymous"`
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
}

func (e *EventDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Anonymous":  e.Anonymous,
		"Name":       e.Name,
		"Parameters": e.Parameters,
	}
}

func (e *EventDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["anonymous"]; ok {
		e.Anonymous = value.(bool)
	}
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		e.Parameters = res
	}
}

// ----------------------------------------------------------------------------
// ModifierDefinition node
type ModifierDefinition struct {
	Common
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
	Visibility string        `json:"visibility"`
}

func (m *ModifierDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":       m.Name,
		"Parameters": m.Parameters,
		"Visibility": m.Visibility,
	}
}

func (m *ModifierDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		m.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		m.Parameters = res
	}
	if value, ok := (*data)["visibility"]; ok {
		m.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ModifierInvocation node
type ModifierInvocation struct {
	Common
	Arguments    []Common `json:"arguments"`
	ModifierName Common   `json:"modifierName"`
}

func (m *ModifierInvocation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments":    m.Arguments,
		"ModifierName": m.ModifierName,
	}
}

func (m *ModifierInvocation) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["arguments"]; ok {
		m.Arguments = value.([]Common)
	}
	if value, ok := (*data)["modifierName"]; ok {
		m.ModifierName = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// InheritanceSpecifier node
type InheritanceSpecifier struct {
	Common
	Arguments []Common            `json:"arguments"`
	BaseName  UserDefinedTypeName `json:"baseName"`
}

func (i *InheritanceSpecifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments": i.Arguments,
		"BaseName":  i.BaseName,
	}
}

func (i *InheritanceSpecifier) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["arguments"]; ok {
		if len(value.([]interface{})) == 0 {
			i.Arguments = make([]Common, 0)
		} else {
			panic("Arguments is NOT empty.")
		}
	}
	if value, ok := (*data)["baseName"]; ok {
		var res UserDefinedTypeName
		value := value.(map[string]interface{})
		res.Constructor(&value)
		i.BaseName = res
	}
}

// ----------------------------------------------------------------------------
// StructDefinition node
type StructDefinition struct {
	Common
	CanonicalName string                `json:"canonicalName"`
	Members       []VariableDeclaration `json:"members"`
	Name          string                `json:"name"`
	Scope         int                   `json:"scope"`
	Visibility    string                `json:"visibility"`
}

func (s *StructDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": s.CanonicalName,
		"Members":       s.Members,
		"Name":          s.Name,
		"Scope":         s.Scope,
		"Visibility":    s.Visibility,
	}
}

func (s *StructDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["canonicalName"]; ok {
		s.CanonicalName = value.(string)
	}
	if value, ok := (*data)["members"]; ok {
		var res = make([]VariableDeclaration, 0)
		value := value.([]interface{})
		for _, v := range value {
			v := v.(map[string]interface{})
			var res VariableDeclaration
			res.Constructor(&v)
			s.Members = append(s.Members, res)
		}
		s.Members = res
	}
	if value, ok := (*data)["name"]; ok {
		s.Name = value.(string)
	}
	if value, ok := (*data)["scope"]; ok {
		var res int
		value := value.(float64)
		res = (int)(value)
		s.Scope = res
	}
	if value, ok := (*data)["visibility"]; ok {
		s.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// UsingForDirective node
type UsingForDirective struct {
	Common
	LibraryName UserDefinedTypeName `json:"libraryName"`
	TypeName    ElementaryTypeName  `json:"typeName"`
}

func (u *UsingForDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"LibraryName": u.LibraryName,
		"TypeName":    u.TypeName,
	}
}

func (u *UsingForDirective) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["libraryName"]; ok {
		var res UserDefinedTypeName
		value := value.(map[string]interface{})
		res.Constructor(&value)
		u.LibraryName = res
	}
	if value, ok := (*data)["typeName"]; ok {
		var res ElementaryTypeName
		value := value.(map[string]interface{})
		res.Constructor(&value)
		u.TypeName = res
	}
}

// ----------------------------------------------------------------------------
// EnumValue node
type EnumValue struct {
	Common
	Name string `json:"name"`
}

func (e *EnumValue) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name": e.Name,
	}
}

func (e *EnumValue) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
}

// ----------------------------------------------------------------------------
// EnumDefinition node
type EnumDefinition struct {
	Common
	CanonicalName string      `json:"canonicalName"`
	Members       []EnumValue `json:"members"`
	Name          string      `json:"name"`
}

func (e *EnumDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": e.CanonicalName,
		"Members":       e.Members,
		"Name":          e.Name,
	}
}

func (e *EnumDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["canonicalName"]; ok {
		e.CanonicalName = value.(string)
	}
	if value, ok := (*data)["members"]; ok {
		var res = make([]EnumValue, 0)
		value := value.([]interface{})
		for _, v := range value {
			v := v.(map[string]interface{})
			var res EnumValue
			res.Constructor(&v)
			e.Members = append(e.Members, res)
		}
		e.Members = res
	}
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ArraryTypeName node
type ArraryTypeName struct {
	Common
	BaseType         Common           `json:"baseType"`
	Length           string           `json:"length"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (a *ArraryTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"BaseType":         a.BaseType,
		"Length":           a.Length,
		"TypeDescriptions": a.TypeDescriptions,
	}
}

func (a *ArraryTypeName) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["baseType"]; ok {
		a.BaseType = value.(Common)
	}
	if value, ok := (*data)["length"]; ok {
		a.Length = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		a.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// IdentifierPath node
type IdentifierPath struct {
	Common
	Name                 string   `json:"name"`
	NameLocations        []string `json:"nameLocation"`
	ReferenceDeclaration int      `json:"referencedDeclaration"`
}

func (i *IdentifierPath) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":                 i.Name,
		"NameLocations":        i.NameLocations,
		"ReferenceDeclaration": i.ReferenceDeclaration,
	}
}

func (i *IdentifierPath) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		i.Name = value.(string)
	}
	if value, ok := (*data)["nameLocation"]; ok {
		i.NameLocations = value.([]string)
	}
	if value, ok := (*data)["referencedDeclaration"]; ok {
		i.ReferenceDeclaration = value.(int)
	}
}

func (i *IdentifierPath) Describe() string {
	return fmt.Sprintf("This is an identifier path.")
}

// ----------------------------------------------------------------------------
// TryCatchClause node
type TryCatchClause struct {
	Common
	Block         Block         `json:"block"`
	ErrorName     string        `json:"errorName"`
	ParameterList ParameterList `json:"parameterList"`
}

func (t *TryCatchClause) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Block":         t.Block,
		"ErrorName":     t.ErrorName,
		"ParameterList": t.ParameterList,
	}
}

func (t *TryCatchClause) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["block"]; ok {
		var res Block
		value := value.(map[string]interface{})
		res.Constructor(&value)
		t.Block = res
	}
	if value, ok := (*data)["errorName"]; ok {
		t.ErrorName = value.(string)
	}
	if value, ok := (*data)["parameterList"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		t.ParameterList = res
	}
}

// ----------------------------------------------------------------------------
// Helper function to convert a map[string]interface{} to an ASTNode

func StringToASTNode(data map[string]interface{}) (ASTNode, error) {
	//nodeType string, src string, id int

	nodeType, ok := data["nodeType"].(string)
	if !ok || nodeType == "" {
		return nil, fmt.Errorf("nodeType not found")
	}

	src := data["src"].(string)
	if !ok || src == "" {
		return nil, fmt.Errorf("src not found")
	}

	id := int(data["id"].(float64))
	if !ok || id == 0 {
		return nil, fmt.Errorf("id not found or id is 0")
	}

	switch nodeType {
	case "SourceUnit":
		return &SourceUnit{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PragmaDirective":
		return &PragmaDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ContractDefinition":
		return &ContractDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Block":
		return &Block{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Identifier":
		return &Identifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TypeDescriptions":
		return &TypeDescriptions{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "BinaryOperation":
		return &BinaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Literal":
		return &Literal{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IfStatement":
		return &IfStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Return":
		return &Return{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclaration":
		return &VariableDeclaration{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeName":
		return &ElementaryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclarationStatement":
		return &VariableDeclarationStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionCall":
		return &FunctionCall{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ExpressionStatement":
		return &ExpressionStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionDefinition":
		return &FunctionDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ParameterList":
		return &ParameterList{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EventDefinition":
		return &EventDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Assignment":
		return &Assignment{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "MemberAccess":
		return &MemberAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PlacehoderStatement":
		return &PlacehoderStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierDefinition":
		return &ModifierDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeNameExpression":
		return &ElementaryTypeNameExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierInvocation":
		return &ModifierInvocation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UserDefinedTypeName":
		return &UserDefinedTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "InheritanceSpecifier":
		return &InheritanceSpecifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UnaryOperation":
		return &UnaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Mapping":
		return &Mapping{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "StructDefinition":
		return &StructDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UsingForDirective":
		return &UsingForDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IndexAccess":
		return &IndexAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumValue":
		return &EnumValue{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumDefinition":
		return &EnumDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ArraryTypeName":
		return &ArraryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Break":
		return &Break{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TupleExpression":
		return &TupleExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "NewExpression":
		return &NewExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	// Statements
	case "TryCatchClause":
		return &TryCatchClause{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ForStatement":
		return &ForStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil

	default:
		return nil, fmt.Errorf("nodeType %s not found", nodeType)
	}
}
