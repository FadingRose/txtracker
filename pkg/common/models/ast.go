package models

import (
	"fmt"
	"txtracker/pkg/logger"
)

type ASTNode interface {
	Describe() string
	AddChild(child *Common)
	SetParent(parent *Common)
	Instace() *Common
	Attributes
}

type Attributes interface {
	Attributes() map[string]interface{}
	Constructor(*map[string]interface{})
}

// `Statement`:
// Block | Break | Continue | DoWhileStatement | EmitStatement | ExpressionStatement | ForStatement | IfStatement | InlineAssembly | PlaceholderStatement | Return | RevertStatement | TryStatement | UncheckedBlock | VariableDeclarationStatement | WhileStatement
type Statement interface {
	DescribeStatement() string
}

// `TypeName`: ArrayTypeName | ElementaryTypeName | FunctionTypeName | Mapping | UserDefinedTypeName
type TypeName interface {
	DescribeTypeName() string
}

// `Mutabilityâ€œ:
// "mutable" | "immutable" | "constant"
type Mutability string

const (
	Mutable   Mutability = "mutable"
	Immutable Mutability = "immutable"
	Constant  Mutability = "constant"
)

// `SourceLocation`: string
type SourceLocation string

// `StateMutability`: "pure" | "view" | "payable" | "nonpayable"
type StateMutability string

const (
	Pure       StateMutability = "pure"
	View       StateMutability = "view"
	Payable    StateMutability = "payable"
	Nonpayable StateMutability = "nonpayable"
)

// `StorageLocation`: "default" | "memory" | "storage" | "calldata"
type StorageLocation string

const (
	Default  StorageLocation = "default"
	Memory   StorageLocation = "memory"
	Storage  StorageLocation = "storage"
	CallData StorageLocation = "calldata"
)

// `Visibility`: "external" | "internal" | "public" | "private"
type Visibility string

const (
	External Visibility = "external"
	Internal Visibility = "internal"
	Public   Visibility = "public"
	Private  Visibility = "private"
)

// ast.go: corresponds to the AST JSON file generated by the Solidity compiler.
type Common struct {
	NodeType string `json:"nodeType"`
	Src      string `json:"src"` // location in the source code
	ID       int    `json:"id"`
	Parent   *Common
	Children []*Common //refactor here
}

func (c *Common) Describe() string {
	return fmt.Sprintf("This is a %s node.", c.NodeType)
}

func (c *Common) AddChild(child *Common) {
	c.Children = append(c.Children, child)
}

func (c *Common) SetParent(parent *Common) {
	c.Parent = parent
}

func (c *Common) Instace() *Common {
	return c
}

// Top-level node for a .sol file
type SourceUnit struct {
	Common
	AbsolutePath    string         `json:"absolutePath"`
	ExportedSymbols map[string]int `json:"exportedSymbols"` // 'symboleName': 'nodeId
}

func (s *SourceUnit) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"AbsolutePath":    s.AbsolutePath,
		"ExportedSymbols": s.ExportedSymbols,
	}
}

func (s *SourceUnit) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["absolutePath"]; ok {
		s.AbsolutePath = value.(string)
	}
	if value, ok := (*data)["exportedSymbols"]; ok {
		var res = make(map[string]int)
		value := value.(map[string]interface{})
		for key, val := range value {
			v := val.([]interface{})[0].(float64)
			res[key] = int(v)
		}
		s.ExportedSymbols = res
	}

}

// ----------------------------------------------------------------------------
// Compiler version node
type PragmaDirective struct {
	Common
	Literals []string `json:"literals"`
}

func (p *PragmaDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Literals": p.Literals,
	}
}

func (p *PragmaDirective) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["literals"]; ok {
		var res = make([]string, 0)
		for _, v := range value.([]interface{}) {
			res = append(res, v.(string))
		}
		p.Literals = res
	}
}

// ----------------------------------------------------------------------------
// ContractDefinition
type ContractDefinition struct {
	Common
	Name                     string                 `json:"name"`
	BaseContracts            []InheritanceSpecifier `json:"baseContracts"` //?
	ContractDependenceies    []int                  `json:"contractDependencies"`
	LinearizaedBaseContracts []int                  `json:"linearizedBaseContracts"`
	ContractKind             string                 `json:"contractKind"`
}

func (c *ContractDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":                     c.Name,
		"BaseContracts":            c.BaseContracts,
		"ContractDependenceies":    c.ContractDependenceies,
		"LinearizaedBaseContracts": c.LinearizaedBaseContracts,
		"ContractKind":             c.ContractKind,
	}
}

// TODO : Test the `baseContracts` is NOT empty
func (c *ContractDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		c.Name = value.(string)
	}
	if value, ok := (*data)["baseContracts"]; ok {
		if len(value.([]interface{})) == 0 {
			c.BaseContracts = []InheritanceSpecifier{}
		} else {
			var res = make([]InheritanceSpecifier, 0)
			for _, v := range value.([]interface{}) {
				v := v.(map[string]interface{})
				var inheritanceSpecifier InheritanceSpecifier
				inheritanceSpecifier.Constructor(&v)
				res = append(res, inheritanceSpecifier)
			}
			c.BaseContracts = res
		}

	}
	if value, ok := (*data)["contractDependencies"]; ok {
		if len(value.([]interface{})) == 0 {
			c.ContractDependenceies = []int{}
		} else {
			var res = make([]int, 0)
			for _, v := range value.([]interface{}) {
				v := v.(float64)
				res = append(res, (int)(v))
			}
			c.ContractDependenceies = res
		}

	}
	if value, ok := (*data)["linearizedBaseContracts"]; ok {
		var res = make([]int, 0)
		for _, v := range value.([]interface{}) {
			v := v.(float64)
			res = append(res, (int)(v))
		}
		c.LinearizaedBaseContracts = res
	}
	if value, ok := (*data)["contractKind"]; ok {
		c.ContractKind = value.(string)
	}
}

// ----------------------------------------------------------------------------
// Identifier node
type Identifier struct {
	Common
	ArgumentTypes          []TypeDescriptions `json:"argumentTypes"`
	OverloadedDeclarations []string           `json:"overloadedDeclarations"`
	ReferencedDeclaration  int                `json:"referencedDeclaration"`
	TypeDescriptions       TypeDescriptions   `json:"typeDescriptions"`
}

func (i *Identifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":          i.ArgumentTypes,
		"OverloadedDeclarations": i.OverloadedDeclarations,
		"ReferencedDeclaration":  i.ReferencedDeclaration,
		"TypeDescriptions":       i.TypeDescriptions,
	}
}

func (i *Identifier) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		if value == nil {
			i.ArgumentTypes = []TypeDescriptions{}
		} else {
			var res = make([]TypeDescriptions, 0)
			for _, v := range value.([]interface{}) {
				v := v.(map[string]interface{})
				var typeDescriptions TypeDescriptions
				typeDescriptions.Constructor(&v)
				res = append(res, typeDescriptions)
			}
			i.ArgumentTypes = res
		}
		//i.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["overloadedDeclarations"]; ok {
		value := value.([]interface{})
		if len(value) == 0 {
			i.OverloadedDeclarations = []string{}
		} else {
			logger.Fatal.Fatalf("OverloadedDeclarations is NOT empty.")
			panic("OverloadedDeclarations is NOT empty.")
		}
		//i.OverloadedDeclarations = value.([]string)
	}
	if value, ok := (*data)["referencedDeclaration"]; ok {
		var res int
		value := value.(float64)
		res = (int)(value)
		i.ReferencedDeclaration = res
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		var res TypeDescriptions
		value := value.(map[string]interface{})
		res.Constructor(&value)
		i.TypeDescriptions = res
	}
}

func (i *Identifier) DescribeExpression() string {
	return fmt.Sprintf("This is an identifier expression.")
}

// ----------------------------------------------------------------------------
// TypeDescriptions node
type TypeDescriptions struct {
	Common
	TypeString     string `json:"typeString"`
	TypeIdentifier string `json:"typeIdentifier"`
}

func (t *TypeDescriptions) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"TypeString":     t.TypeString,
		"TypeIdentifier": t.TypeIdentifier,
	}
}

func (t *TypeDescriptions) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["typeString"]; ok {
		t.TypeString = value.(string)
	}
	if value, ok := (*data)["typeIdentifier"]; ok {
		t.TypeIdentifier = value.(string)
	}
}

// ----------------------------------------------------------------------------
// Literal node
type Literal struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	HexValue         string           `json:"hexValue"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	Kind             string           `json:"kind"`
	LValueRequested  bool             `json:"lValueRequested"`
	Subdenomination  string           `json:"subdenomination"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	Value            string           `json:"value"`
}

func (l *Literal) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    l.ArgumentTypes,
		"HexValue":         l.HexValue,
		"IsConstant":       l.IsConstant,
		"IsLValue":         l.IsLValue,
		"IsPure":           l.IsPure,
		"Kind":             l.Kind,
		"LValueRequested":  l.LValueRequested,
		"Subdenomination":  l.Subdenomination,
		"TypeDescriptions": l.TypeDescriptions,
		"Value":            l.Value,
	}
}

func (l *Literal) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		if value == nil {
			l.ArgumentTypes = []string{}
		} else {
			l.ArgumentTypes = value.([]string) //TODO: Check if it is string
		}
	}
	if value, ok := (*data)["hexValue"]; ok {
		l.HexValue = value.(string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		l.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		l.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		l.IsPure = value.(bool)
	}
	if value, ok := (*data)["kind"]; ok {
		l.Kind = value.(string)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		l.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["subdenomination"]; ok {
		if value == nil {
			l.Subdenomination = ""
		} else {
			panic("Subdenomination is NOT empty.")
		}
		//l.Subdenomination = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		value := value.(map[string]interface{})
		var res TypeDescriptions
		res.Constructor(&value)
		l.TypeDescriptions = res
	}
	if value, ok := (*data)["value"]; ok {
		l.Value = value.(string)
	}
}

func (l *Literal) DescribeExpression() string {
	return fmt.Sprintf("This is a literal expression.")
}

// ----------------------------------------------------------------------------
// VariableDeclaration node
type VariableDeclaration struct {
	Common
	Constant         bool               `json:"constant"`
	Name             string             `json:"name"`
	Scope            int                `json:"scope"`
	StateVariable    bool               `json:"stateVariable"`
	StorageLocation  string             `json:"storageLocation"`
	TypeDescriptions TypeDescriptions   `json:"typeDescriptions"`
	TypeName         ElementaryTypeName `json:"typeName"`
	Value            Literal            `json:"value"`
	Visibility       string             `json:"visibility"`
}

func (v *VariableDeclaration) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Constant":         v.Constant,
		"Name":             v.Name,
		"Scope":            v.Scope,
		"StateVariable":    v.StateVariable,
		"StorageLocation":  v.StorageLocation,
		"TypeDescriptions": v.TypeDescriptions,
		"TypeName":         v.TypeName,
		"Value":            v.Value,
		"Visibility":       v.Visibility,
	}
}

func (v *VariableDeclaration) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["constant"]; ok {
		v.Constant = value.(bool)
	}
	if value, ok := (*data)["name"]; ok {
		v.Name = value.(string)
	}
	if value, ok := (*data)["scope"]; ok {
		v.Scope = (int)(value.(float64))
	}
	if value, ok := (*data)["stateVariable"]; ok {
		v.StateVariable = value.(bool)
	}
	if value, ok := (*data)["storageLocation"]; ok {
		v.StorageLocation = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		value := value.(map[string]interface{})
		var res TypeDescriptions
		res.Constructor(&value)
		v.TypeDescriptions = res
	}
	if value, ok := (*data)["typeName"]; ok {
		value := value.(map[string]interface{})
		var res ElementaryTypeName
		res.Constructor(&value)
		v.TypeName = res
	}
	if value, ok := (*data)["value"]; ok {
		var res Literal
		if value == nil {
			res = Literal{}
		} else {
			value := value.(map[string]interface{})
			res.Constructor(&value)
		}
		v.Value = res
	}
	if value, ok := (*data)["visibility"]; ok {
		v.Visibility = value.(string)
	}
}

func (v *VariableDeclaration) Describe() string {
	return fmt.Sprintf("This is a variable declaration.")
}

// ----------------------------------------------------------------------------
// ElementaryTypeName node

type ElementaryTypeName struct {
	Common
	Name             string           `json:"name"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (e *ElementaryTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":             e.Name,
		"TypeDescriptions": e.TypeDescriptions,
	}
}

func (e *ElementaryTypeName) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		value := value.(map[string]interface{})
		var res TypeDescriptions
		res.Constructor(&value)
		e.TypeDescriptions = res
	}
}

// ----------------------------------------------------------------------------
// FunctionCall node
type FunctionCall struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	Arguments        []Expression     `json:"arguments"`
	Expression       Identifier       `json:"expression"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	Kind             string           `json:"kind"`
	LValueRequested  bool             `json:"lValueRequested"`
	Names            []string         `json:"names"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (f *FunctionCall) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    f.ArgumentTypes,
		"Arguments":        f.Arguments,
		"Expression":       f.Expression,
		"IsConstant":       f.IsConstant,
		"IsLValue":         f.IsLValue,
		"IsPure":           f.IsPure,
		"Kind":             f.Kind,
		"LValueRequested":  f.LValueRequested,
		"Names":            f.Names,
		"TypeDescriptions": f.TypeDescriptions,
	}
}

func (f *FunctionCall) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		if value == nil {
			f.ArgumentTypes = []string{}
		} else {
			logger.Fatal.Fatalf("ArgumentTypes is NOT empty.")
			panic("ArgumentTypes is NOT empty.")
		}
	}
	if value, ok := (*data)["arguments"]; ok {
		var res = make([]Expression, 0)
		for _, v := range value.([]interface{}) {
			v := v.(map[string]interface{})
			switch v["nodeType"] {
			case "BinaryOperation":
				var r BinaryOperation
				r.Constructor(&v)
				res = append(res, &r)
			case "Literal":
				var r Literal
				r.Constructor(&v)
				res = append(res, &r)
			default:
				logger.Fatal.Fatalf("Unknown type: %v", v["nodeType"])
				panic("Unknown type")
			}
		}
		f.Arguments = res
	}
	if value, ok := (*data)["expression"]; ok {
		var res Identifier
		value := value.(map[string]interface{})
		res.Constructor(&value)
		f.Expression = res
	}
	if value, ok := (*data)["isConstant"]; ok {
		f.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		f.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		f.IsPure = value.(bool)
	}
	if value, ok := (*data)["kind"]; ok {
		f.Kind = value.(string)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		f.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["names"]; ok {
		value := value.([]interface{})
		if len(value) == 0 {
			f.Names = []string{}
		} else {
			logger.Fatal.Fatalf("Names is NOT empty.")
			panic("Names is NOT empty.")
		}
		//f.Names = value.([]string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		var res TypeDescriptions
		value := value.(map[string]interface{})
		res.Constructor(&value)
		f.TypeDescriptions = res
	}
}

func (f *FunctionCall) DescribeExpression() string {
	return fmt.Sprintf("This is a function call expression.")
}

// ----------------------------------------------------------------------------
// FunctionDefinition node
type FunctionDefinition struct {
	Common
	Body             Block                `json:"body"`
	Implemented      bool                 `json:"implemented"`
	IsConstructor    bool                 `json:"isConstructor"`
	IsDeclaredConst  bool                 `json:"isDeclaredConst"`
	Modifiers        []ModifierInvocation `json:"modifiers"`
	Name             string               `json:"name"`
	Parameters       ParameterList        `json:"parameters"`
	Payable          bool                 `json:"payable"`
	ReturnParameters ParameterList        `json:"returnParameters"`
	Scope            int                  `json:"scope"`
	StateMutability  string               `json:"stateMutability"`
	SuperFunction    int                  `json:"superFunction"`
	Visibility       string               `json:"visibility"`
}

func (f *FunctionDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Body":             f.Body,
		"Implemented":      f.Implemented,
		"IsConstructor":    f.IsConstructor,
		"IsDeclaredConst":  f.IsDeclaredConst,
		"Modifiers":        f.Modifiers,
		"Name":             f.Name,
		"Parameters":       f.Parameters,
		"Payable":          f.Payable,
		"ReturnParameters": f.ReturnParameters,
		"Scope":            f.Scope,
		"StateMutability":  f.StateMutability,
		"SuperFunction":    f.SuperFunction,
		"Visibility":       f.Visibility,
	}
}

// TODO: Test Modifier is NOT empty
func (f *FunctionDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["body"]; ok {
		var res Block
		value := value.(map[string]interface{})
		res.Constructor(&value)
		f.Body = res
	}
	if value, ok := (*data)["implemented"]; ok {
		f.Implemented = value.(bool)
	}
	if value, ok := (*data)["isConstructor"]; ok {
		f.IsConstructor = value.(bool)
	}
	if value, ok := (*data)["isDeclaredConst"]; ok {
		f.IsDeclaredConst = value.(bool)
	}
	if value, ok := (*data)["modifiers"]; ok {
		if len(value.([]interface{})) == 0 {
			f.Modifiers = make([]ModifierInvocation, 0)
		} else {
		}
	}
	if value, ok := (*data)["name"]; ok {
		f.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		f.Parameters = res
	}
	if value, ok := (*data)["payable"]; ok {
		f.Payable = value.(bool)
	}
	if value, ok := (*data)["returnParameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		f.ReturnParameters = res
	}
	if value, ok := (*data)["scope"]; ok {
		res := value.(float64)
		f.Scope = (int)(res)
	}
	if value, ok := (*data)["stateMutability"]; ok {
		f.StateMutability = value.(string)
	}
	if value, ok := (*data)["superFunction"]; ok {
		if value == nil {
			f.SuperFunction = -1
		} else {
			var res int
			value := value.(float64)
			res = (int)(value)
			f.SuperFunction = res
		}

	}
	if value, ok := (*data)["visibility"]; ok {
		f.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ParameterList node
type ParameterList struct {
	Common
	Parameters []Common `json:"parameters"`
}

func (p *ParameterList) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Parameters": p.Parameters,
	}
}

// TODO: Test the `parameters` is NOT empty
func (p *ParameterList) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["parameters"]; ok {
		if len(value.([]interface{})) == 0 {
			p.Parameters = make([]Common, 0) //WARNING:::CHECK Common, infact it may be Identifier or VariableDeclaration?
		} else {

		}
	}
}

// ----------------------------------------------------------------------------
// EventDefinition node
type EventDefinition struct {
	Common
	Anonymous  bool          `json:"anonymous"`
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
}

func (e *EventDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Anonymous":  e.Anonymous,
		"Name":       e.Name,
		"Parameters": e.Parameters,
	}
}

func (e *EventDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["anonymous"]; ok {
		e.Anonymous = value.(bool)
	}
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		e.Parameters = res
	}
}

// ----------------------------------------------------------------------------
// MemberAccess node
type MemberAccess struct {
	Common
	ArgumentTypes         []string         `json:"argumentTypes"`
	Expression            Expression       `json:"expression"`
	IsConstant            bool             `json:"isConstant"`
	IsLValue              bool             `json:"isLValue"`
	IsPure                bool             `json:"isPure"`
	LValueRequested       bool             `json:"lValueRequested"`
	MemberName            string           `json:"memberName"`
	ReferencedDeclaration int              `json:"referencedDeclaration"`
	TypeDescriptions      TypeDescriptions `json:"typeDescriptions"`
}

func (m *MemberAccess) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":         m.ArgumentTypes,
		"Expression":            m.Expression,
		"IsConstant":            m.IsConstant,
		"IsLValue":              m.IsLValue,
		"IsPure":                m.IsPure,
		"LValueRequested":       m.LValueRequested,
		"MemberName":            m.MemberName,
		"ReferencedDeclaration": m.ReferencedDeclaration,
		"TypeDescriptions":      m.TypeDescriptions,
	}
}

func (m *MemberAccess) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		if value == nil {
			m.ArgumentTypes = []string{}
		} else {
			logger.Fatal.Fatalf("ArgumentTypes is NOT empty.")
			panic("ArgumentTypes is NOT empty.")
		}
		//m.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["expression"]; ok {
		var res Expression
		value := value.(map[string]interface{})
		switch value["nodeType"] {
		case "Identifier":
			var r Identifier
			r.Constructor(&value)
			res = &r
			m.Expression = res

		// case "MemberAccess":
		// 	var r MemberAccess
		// 	r.Constructor(&value)
		// 	res = &r
		default:
			logger.Fatal.Fatalf("Unknown type: %v", value["nodeType"])
			panic("Unknown type")
		}

	}
	if value, ok := (*data)["isConstant"]; ok {
		m.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		m.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		m.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		m.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["memberName"]; ok {
		m.MemberName = value.(string)
	}
	if value, ok := (*data)["referencedDeclaration"]; ok {
		m.ReferencedDeclaration = value.(int)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		m.TypeDescriptions = value.(TypeDescriptions)
	}
}

func (m *MemberAccess) DescribeRightHandSide() string {
	return fmt.Sprintf("This is a member access expression.")
}

// ----------------------------------------------------------------------------
// ModifierDefinition node
type ModifierDefinition struct {
	Common
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
	Visibility string        `json:"visibility"`
}

func (m *ModifierDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":       m.Name,
		"Parameters": m.Parameters,
		"Visibility": m.Visibility,
	}
}

func (m *ModifierDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		m.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		m.Parameters = res
	}
	if value, ok := (*data)["visibility"]; ok {
		m.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ElementaryTypeNameExpression node
type ElementaryTypeNameExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	TypeName         string           `json:"typeName"`
}

func (e *ElementaryTypeNameExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    e.ArgumentTypes,
		"IsConstant":       e.IsConstant,
		"IsLValue":         e.IsLValue,
		"IsPure":           e.IsPure,
		"LValueRequested":  e.LValueRequested,
		"TypeDescriptions": e.TypeDescriptions,
		"TypeName":         e.TypeName,
	}
}

func (e *ElementaryTypeNameExpression) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		e.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		e.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		e.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		e.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		e.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		e.TypeDescriptions = value.(TypeDescriptions)
	}
	if value, ok := (*data)["typeName"]; ok {
		e.TypeName = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ModifierInvocation node
type ModifierInvocation struct {
	Common
	Arguments    []Common `json:"arguments"`
	ModifierName Common   `json:"modifierName"`
}

func (m *ModifierInvocation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments":    m.Arguments,
		"ModifierName": m.ModifierName,
	}
}

func (m *ModifierInvocation) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["arguments"]; ok {
		m.Arguments = value.([]Common)
	}
	if value, ok := (*data)["modifierName"]; ok {
		m.ModifierName = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// UserDefinedTypeName node
type UserDefinedTypeName struct {
	Common
	ContractScope        string           `json:"contractScope"`
	ReferenceDeclaration int              `json:"referencedDeclaration"`
	TypeDescriptions     TypeDescriptions `json:"typeDescriptions"`
}

func (u *UserDefinedTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ContractScope":        u.ContractScope,
		"ReferenceDeclaration": u.ReferenceDeclaration,
		"TypeDescriptions":     u.TypeDescriptions,
	}
}

func (u *UserDefinedTypeName) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["contractScope"]; ok {
		if value == nil {
			u.ContractScope = ""
		} else {
			u.ContractScope = value.(string) //TODO: Check if it is string
		}
	}
	if value, ok := (*data)["referencedDeclaration"]; ok {
		var res int
		value := value.(float64)
		res = (int)(value)
		u.ReferenceDeclaration = res
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		var res TypeDescriptions
		value := value.(map[string]interface{})
		res.Constructor(&value)
		u.TypeDescriptions = res
	}
}

// ----------------------------------------------------------------------------
// InheritanceSpecifier node
type InheritanceSpecifier struct {
	Common
	Arguments []Common            `json:"arguments"`
	BaseName  UserDefinedTypeName `json:"baseName"`
}

func (i *InheritanceSpecifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments": i.Arguments,
		"BaseName":  i.BaseName,
	}
}

func (i *InheritanceSpecifier) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["arguments"]; ok {
		if len(value.([]interface{})) == 0 {
			i.Arguments = make([]Common, 0)
		} else {
			panic("Arguments is NOT empty.")
		}
	}
	if value, ok := (*data)["baseName"]; ok {
		var res UserDefinedTypeName
		value := value.(map[string]interface{})
		res.Constructor(&value)
		i.BaseName = res
	}
}

// ----------------------------------------------------------------------------
// UnaryOperation node
type UnaryOperation struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	Operator         string           `json:"operator"`
	Prefix           bool             `json:"prefix"`
	SubExpression    Common           `json:"subExpression"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (u *UnaryOperation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    u.ArgumentTypes,
		"IsConstant":       u.IsConstant,
		"IsLValue":         u.IsLValue,
		"IsPure":           u.IsPure,
		"LValueRequested":  u.LValueRequested,
		"Operator":         u.Operator,
		"Prefix":           u.Prefix,
		"SubExpression":    u.SubExpression,
		"TypeDescriptions": u.TypeDescriptions,
	}
}

func (u *UnaryOperation) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		u.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		u.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		u.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		u.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		u.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["operator"]; ok {
		u.Operator = value.(string)
	}
	if value, ok := (*data)["prefix"]; ok {
		u.Prefix = value.(bool)
	}
	if value, ok := (*data)["subExpression"]; ok {
		u.SubExpression = value.(Common)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		u.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// Mapping node
type Mapping struct {
	Common
	KeyType          Common           `json:"keyType"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	ValueType        Common           `json:"valueType"`
}

func (m *Mapping) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"KeyType":          m.KeyType,
		"TypeDescriptions": m.TypeDescriptions,
		"ValueType":        m.ValueType,
	}
}

func (m *Mapping) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["keyType"]; ok {
		m.KeyType = value.(Common)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		m.TypeDescriptions = value.(TypeDescriptions)
	}
	if value, ok := (*data)["valueType"]; ok {
		m.ValueType = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// StructDefinition node
type StructDefinition struct {
	Common
	CanonicalName string                `json:"canonicalName"`
	Members       []VariableDeclaration `json:"members"`
	Name          string                `json:"name"`
	Scope         int                   `json:"scope"`
	Visibility    string                `json:"visibility"`
}

func (s *StructDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": s.CanonicalName,
		"Members":       s.Members,
		"Name":          s.Name,
		"Scope":         s.Scope,
		"Visibility":    s.Visibility,
	}
}

func (s *StructDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["canonicalName"]; ok {
		s.CanonicalName = value.(string)
	}
	if value, ok := (*data)["members"]; ok {
		var res = make([]VariableDeclaration, 0)
		value := value.([]interface{})
		for _, v := range value {
			v := v.(map[string]interface{})
			var res VariableDeclaration
			res.Constructor(&v)
			s.Members = append(s.Members, res)
		}
		s.Members = res
	}
	if value, ok := (*data)["name"]; ok {
		s.Name = value.(string)
	}
	if value, ok := (*data)["scope"]; ok {
		var res int
		value := value.(float64)
		res = (int)(value)
		s.Scope = res
	}
	if value, ok := (*data)["visibility"]; ok {
		s.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// UsingForDirective node
type UsingForDirective struct {
	Common
	LibraryName UserDefinedTypeName `json:"libraryName"`
	TypeName    ElementaryTypeName  `json:"typeName"`
}

func (u *UsingForDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"LibraryName": u.LibraryName,
		"TypeName":    u.TypeName,
	}
}

func (u *UsingForDirective) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["libraryName"]; ok {
		var res UserDefinedTypeName
		value := value.(map[string]interface{})
		res.Constructor(&value)
		u.LibraryName = res
	}
	if value, ok := (*data)["typeName"]; ok {
		var res ElementaryTypeName
		value := value.(map[string]interface{})
		res.Constructor(&value)
		u.TypeName = res
	}
}

// ----------------------------------------------------------------------------
// IndexAccess node
type IndexAccess struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	BaseExpression   []Common         `json:"baseExpression"`
	IndexExpression  []Common         `json:"indexExpression"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (i *IndexAccess) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    i.ArgumentTypes,
		"BaseExpression":   i.BaseExpression,
		"IndexExpression":  i.IndexExpression,
		"IsConstant":       i.IsConstant,
		"IsLValue":         i.IsLValue,
		"IsPure":           i.IsPure,
		"LValueRequested":  i.LValueRequested,
		"TypeDescriptions": i.TypeDescriptions,
	}
}

func (i *IndexAccess) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		i.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["baseExpression"]; ok {
		i.BaseExpression = value.([]Common)
	}
	if value, ok := (*data)["indexExpression"]; ok {
		i.IndexExpression = value.([]Common)
	}
	if value, ok := (*data)["isConstant"]; ok {
		i.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		i.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		i.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		i.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		i.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// EnumValue node
type EnumValue struct {
	Common
	Name string `json:"name"`
}

func (e *EnumValue) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name": e.Name,
	}
}

func (e *EnumValue) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
}

// ----------------------------------------------------------------------------
// EnumDefinition node
type EnumDefinition struct {
	Common
	CanonicalName string      `json:"canonicalName"`
	Members       []EnumValue `json:"members"`
	Name          string      `json:"name"`
}

func (e *EnumDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": e.CanonicalName,
		"Members":       e.Members,
		"Name":          e.Name,
	}
}

func (e *EnumDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["canonicalName"]; ok {
		e.CanonicalName = value.(string)
	}
	if value, ok := (*data)["members"]; ok {
		var res = make([]EnumValue, 0)
		value := value.([]interface{})
		for _, v := range value {
			v := v.(map[string]interface{})
			var res EnumValue
			res.Constructor(&v)
			e.Members = append(e.Members, res)
		}
		e.Members = res
	}
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ArraryTypeName node
type ArraryTypeName struct {
	Common
	BaseType         Common           `json:"baseType"`
	Length           string           `json:"length"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (a *ArraryTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"BaseType":         a.BaseType,
		"Length":           a.Length,
		"TypeDescriptions": a.TypeDescriptions,
	}
}

func (a *ArraryTypeName) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["baseType"]; ok {
		a.BaseType = value.(Common)
	}
	if value, ok := (*data)["length"]; ok {
		a.Length = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		a.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// TupleExpression node
type TupleExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	Components       []Common         `json:"components"`
	IsConstant       bool             `json:"isConstant"`
	IsInlineArray    bool             `json:"isInlineArray"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (t *TupleExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    t.ArgumentTypes,
		"Components":       t.Components,
		"IsConstant":       t.IsConstant,
		"IsInlineArray":    t.IsInlineArray,
		"IsLValue":         t.IsLValue,
		"IsPure":           t.IsPure,
		"LValueRequested":  t.LValueRequested,
		"TypeDescriptions": t.TypeDescriptions,
	}
}

func (t *TupleExpression) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		t.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["components"]; ok {
		t.Components = value.([]Common)
	}
	if value, ok := (*data)["isConstant"]; ok {
		t.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isInlineArray"]; ok {
		t.IsInlineArray = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		t.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		t.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		t.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		t.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// NewExpression node
type NewExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	TypeName         Common           `json:"typeName"`
}

func (n *NewExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    n.ArgumentTypes,
		"IsConstant":       n.IsConstant,
		"IsLValue":         n.IsLValue,
		"IsPure":           n.IsPure,
		"LValueRequested":  n.LValueRequested,
		"TypeDescriptions": n.TypeDescriptions,
		"TypeName":         n.TypeName,
	}
}

func (n *NewExpression) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		n.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		n.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		n.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		n.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		n.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		n.TypeDescriptions = value.(TypeDescriptions)
	}
	if value, ok := (*data)["typeName"]; ok {
		n.TypeName = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// Helper function to convert a map[string]interface{} to an ASTNode

func StringToASTNode(data map[string]interface{}) (ASTNode, error) {
	//nodeType string, src string, id int

	nodeType, ok := data["nodeType"].(string)
	if !ok || nodeType == "" {
		return nil, fmt.Errorf("nodeType not found")
	}

	src := data["src"].(string)
	if !ok || src == "" {
		return nil, fmt.Errorf("src not found")
	}

	id := int(data["id"].(float64))
	if !ok || id == 0 {
		return nil, fmt.Errorf("id not found or id is 0")
	}

	switch nodeType {
	case "SourceUnit":
		return &SourceUnit{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PragmaDirective":
		return &PragmaDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ContractDefinition":
		return &ContractDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Block":
		return &Block{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Identifier":
		return &Identifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TypeDescriptions":
		return &TypeDescriptions{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "BinaryOperation":
		return &BinaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Literal":
		return &Literal{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IfStatement":
		return &IfStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Return":
		return &Return{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclaration":
		return &VariableDeclaration{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeName":
		return &ElementaryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclarationStatement":
		return &VariableDeclarationStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionCall":
		return &FunctionCall{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ExpressionStatement":
		return &ExpressionStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionDefinition":
		return &FunctionDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ParameterList":
		return &ParameterList{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EventDefinition":
		return &EventDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Assignment":
		return &Assignment{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "MemberAccess":
		return &MemberAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PlacehoderStatement":
		return &PlacehoderStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierDefinition":
		return &ModifierDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeNameExpression":
		return &ElementaryTypeNameExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierInvocation":
		return &ModifierInvocation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UserDefinedTypeName":
		return &UserDefinedTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "InheritanceSpecifier":
		return &InheritanceSpecifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UnaryOperation":
		return &UnaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Mapping":
		return &Mapping{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "StructDefinition":
		return &StructDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UsingForDirective":
		return &UsingForDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IndexAccess":
		return &IndexAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumValue":
		return &EnumValue{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumDefinition":
		return &EnumDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ArraryTypeName":
		return &ArraryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ForStatement":
		return &ForStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Break":
		return &Break{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TupleExpression":
		return &TupleExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "NewExpression":
		return &NewExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil

	default:
		return nil, fmt.Errorf("nodeType %s not found", nodeType)
	}
}
