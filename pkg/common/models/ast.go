package models

import (
	"fmt"
)

type ASTNode interface {
	Describe() string
	AddChild(child *Common)
	SetParent(parent *Common)
	Instace() *Common
	Attributes
}

type Attributes interface {
	Attributes() map[string]interface{}
	Constructor(*map[string]interface{})
}

// ast.go: corresponds to the AST JSON file generated by the Solidity compiler.
type Common struct {
	NodeType string `json:"nodeType"`
	Src      string `json:"src"` // location in the source code
	ID       int    `json:"id"`
	Parent   *Common
	Children []*Common //refactor here
}

func (c *Common) Describe() string {
	return fmt.Sprintf("This is a %s node.", c.NodeType)
}

func (c *Common) AddChild(child *Common) {
	c.Children = append(c.Children, child)
}

func (c *Common) SetParent(parent *Common) {
	c.Parent = parent
}

func (c *Common) Instace() *Common {
	return c
}

// Constructors------------------------------------------------------

// Top-level node for a .sol file
type SourceUnit struct {
	Common
	AbsolutePath    string         `json:"absolutePath"`
	ExportedSymbols map[string]int `json:"exportedSymbols"` // 'symboleName': 'nodeId
}

func (s *SourceUnit) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"AbsolutePath":    s.AbsolutePath,
		"ExportedSymbols": s.ExportedSymbols,
	}
}

func (s *SourceUnit) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["absolutePath"]; ok {
		s.AbsolutePath = value.(string)
	}
	if value, ok := (*data)["exportedSymbols"]; ok {
		var res = make(map[string]int)
		value := value.(map[string]interface{})
		for key, val := range value {
			v := val.([]interface{})[0].(float64)
			res[key] = int(v)
		}
		s.ExportedSymbols = res
	}

}

// ----------------------------------------------------------------------------
// Compiler version node
type PragmaDirective struct {
	Common
	Literals []string `json:"literals"`
}

func (p *PragmaDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Literals": p.Literals,
	}
}

func (p *PragmaDirective) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["literals"]; ok {
		var res = make([]string, 0)
		for _, v := range value.([]interface{}) {
			res = append(res, v.(string))
		}
		p.Literals = res
	}
}

// ----------------------------------------------------------------------------
// ContractDefinition
type ContractDefinition struct {
	Common
	Name                     string                 `json:"name"`
	BaseContracts            []InheritanceSpecifier `json:"baseContracts"` //?
	ContractDependenceies    []string               `json:"contractDependencies"`
	LinearizaedBaseContracts []int                  `json:"linearizedBaseContracts"`
	ContractKind             string                 `json:"contractKind"`
}

func (c *ContractDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":                     c.Name,
		"BaseContracts":            c.BaseContracts,
		"ContractDependenceies":    c.ContractDependenceies,
		"LinearizaedBaseContracts": c.LinearizaedBaseContracts,
		"ContractKind":             c.ContractKind,
	}
}

// TODO : Test the `baseContracts` is NOT empty
func (c *ContractDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		c.Name = value.(string)
	}
	if value, ok := (*data)["baseContracts"]; ok {
		if len(value.([]interface{})) == 0 {
			c.BaseContracts = make([]InheritanceSpecifier, 0)
		} else {
			c.BaseContracts = value.([]InheritanceSpecifier) //WARNING
		}

	}
	if value, ok := (*data)["contractDependencies"]; ok {
		if len(value.([]interface{})) == 0 {
			c.ContractDependenceies = make([]string, 0)
		} else {
			c.ContractDependenceies = value.([]string)
		}

	}
	if value, ok := (*data)["linearizedBaseContracts"]; ok {
		var res = make([]int, 0)
		for _, v := range value.([]interface{}) {
			v := v.(float64)
			res = append(res, (int)(v))
		}
		c.LinearizaedBaseContracts = res
	}
	if value, ok := (*data)["contractKind"]; ok {
		c.ContractKind = value.(string)
	}
}

// ----------------------------------------------------------------------------
// Block node, which contains a list of statements between '{' and '}'
type Block struct {
	Common
	Statements []ExpressionStatement `json:"statements"`
}

func (b *Block) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Statements": b.Statements,
	}
}

func (b *Block) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["statements"]; ok {
		b.Statements = value.([]ExpressionStatement)
	}
}

// ----------------------------------------------------------------------------
// Identifier node
type Identifier struct {
	Common
	ArgumentTypes          []string         `json:"argumentTypes"`
	OverloadedDeclarations []string         `json:"overloadedDeclarations"`
	ReferencedDeclaration  int              `json:"referencedDeclaration"`
	TypeDescriptions       TypeDescriptions `json:"typeDescriptions"`
}

func (i *Identifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":          i.ArgumentTypes,
		"OverloadedDeclarations": i.OverloadedDeclarations,
		"ReferencedDeclaration":  i.ReferencedDeclaration,
		"TypeDescriptions":       i.TypeDescriptions,
	}
}

func (i *Identifier) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		i.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["overloadedDeclarations"]; ok {
		i.OverloadedDeclarations = value.([]string)
	}
	if value, ok := (*data)["referencedDeclaration"]; ok {
		i.ReferencedDeclaration = value.(int)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		i.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// TypeDescriptions node
type TypeDescriptions struct {
	Common
	TypeString     string `json:"typeString"`
	TypeIdentifier string `json:"typeIdentifier"`
}

func (t *TypeDescriptions) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"TypeString":     t.TypeString,
		"TypeIdentifier": t.TypeIdentifier,
	}
}

func (t *TypeDescriptions) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["typeString"]; ok {
		t.TypeString = value.(string)
	}
	if value, ok := (*data)["typeIdentifier"]; ok {
		t.TypeIdentifier = value.(string)
	}
}

// ----------------------------------------------------------------------------
// BinaryOperation node
type BinaryOperation struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	CommonType       TypeDescriptions `json:"commonType"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	LeftExpression   Common           `json:"leftExpression"`
	Operator         string           `json:"operator"`
	RightExpression  Common           `json:"rightExpression"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (b *BinaryOperation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    b.ArgumentTypes,
		"CommonType":       b.CommonType,
		"IsConstant":       b.IsConstant,
		"IsLValue":         b.IsLValue,
		"IsPure":           b.IsPure,
		"LValueRequested":  b.LValueRequested,
		"LeftExpression":   b.LeftExpression,
		"Operator":         b.Operator,
		"RightExpression":  b.RightExpression,
		"TypeDescriptions": b.TypeDescriptions,
	}
}

func (b *BinaryOperation) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		b.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["commonType"]; ok {
		b.CommonType = value.(TypeDescriptions)
	}
	if value, ok := (*data)["isConstant"]; ok {
		b.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		b.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		b.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		b.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["leftExpression"]; ok {
		b.LeftExpression = value.(Common)
	}
	if value, ok := (*data)["operator"]; ok {
		b.Operator = value.(string)
	}
	if value, ok := (*data)["rightExpression"]; ok {
		b.RightExpression = value.(Common)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		b.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// Literal node
type Literal struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	HexValue         string           `json:"hexValue"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	Kind             string           `json:"kind"`
	LValueRequested  bool             `json:"lValueRequested"`
	Subdenomination  string           `json:"subdenomination"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	Value            string           `json:"value"`
}

func (l *Literal) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    l.ArgumentTypes,
		"HexValue":         l.HexValue,
		"IsConstant":       l.IsConstant,
		"IsLValue":         l.IsLValue,
		"IsPure":           l.IsPure,
		"Kind":             l.Kind,
		"LValueRequested":  l.LValueRequested,
		"Subdenomination":  l.Subdenomination,
		"TypeDescriptions": l.TypeDescriptions,
		"Value":            l.Value,
	}
}

func (l *Literal) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		l.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["hexValue"]; ok {
		l.HexValue = value.(string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		l.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		l.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		l.IsPure = value.(bool)
	}
	if value, ok := (*data)["kind"]; ok {
		l.Kind = value.(string)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		l.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["subdenomination"]; ok {
		l.Subdenomination = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		value := value.(map[string]interface{})
		var res TypeDescriptions
		res.Constructor(&value)
		l.TypeDescriptions = res
	}
	if value, ok := (*data)["value"]; ok {
		l.Value = value.(string)
	}
}

// ----------------------------------------------------------------------------
// IfStatement node
type IfStatement struct {
	Common
	Condition BinaryOperation `json:"condition"`
	FalseBody Block           `json:"falseBody"`
	TrueBody  Block           `json:"trueBody"`
}

func (i *IfStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Condition": i.Condition,
		"FalseBody": i.FalseBody,
		"TrueBody":  i.TrueBody,
	}
}

func (i *IfStatement) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["condition"]; ok {
		i.Condition = value.(BinaryOperation)
	}
	if value, ok := (*data)["falseBody"]; ok {
		i.FalseBody = value.(Block)
	}
	if value, ok := (*data)["trueBody"]; ok {
		i.TrueBody = value.(Block)
	}
}

// ----------------------------------------------------------------------------
// Return node
type Return struct {
	Common
	Expression               Common `json:"expression"`
	FunctionReturnParameters int    `json:"functionReturnParameters"`
}

func (r *Return) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Expression":               r.Expression,
		"FunctionReturnParameters": r.FunctionReturnParameters,
	}
}

func (r *Return) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["expression"]; ok {
		r.Expression = value.(Common)
	}
	if value, ok := (*data)["functionReturnParameters"]; ok {
		r.FunctionReturnParameters = value.(int)
	}
}

// ----------------------------------------------------------------------------
// VariableDeclaration node
type VariableDeclaration struct {
	Common
	Constant         bool               `json:"constant"`
	Name             string             `json:"name"`
	Scope            int                `json:"scope"`
	StateVariable    bool               `json:"stateVariable"`
	StorageLocation  string             `json:"storageLocation"`
	TypeDescriptions TypeDescriptions   `json:"typeDescriptions"`
	TypeName         ElementaryTypeName `json:"typeName"`
	Value            Literal            `json:"value"`
	Visibility       string             `json:"visibility"`
}

func (v *VariableDeclaration) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Constant":         v.Constant,
		"Name":             v.Name,
		"Scope":            v.Scope,
		"StateVariable":    v.StateVariable,
		"StorageLocation":  v.StorageLocation,
		"TypeDescriptions": v.TypeDescriptions,
		"TypeName":         v.TypeName,
		"Value":            v.Value,
		"Visibility":       v.Visibility,
	}
}

func (v *VariableDeclaration) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["constant"]; ok {
		v.Constant = value.(bool)
	}
	if value, ok := (*data)["name"]; ok {
		v.Name = value.(string)
	}
	if value, ok := (*data)["scope"]; ok {
		v.Scope = (int)(value.(float64))
	}
	if value, ok := (*data)["stateVariable"]; ok {
		v.StateVariable = value.(bool)
	}
	if value, ok := (*data)["storageLocation"]; ok {
		v.StorageLocation = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		value := value.(map[string]interface{})
		var res TypeDescriptions
		res.Constructor(&value)
		v.TypeDescriptions = res
	}
	if value, ok := (*data)["typeName"]; ok {
		value := value.(map[string]interface{})
		var res ElementaryTypeName
		res.Constructor(&value)
		v.TypeName = res
	}
	if value, ok := (*data)["value"]; ok {
		value := value.(map[string]interface{})
		var res Literal
		res.Constructor(&value)
		v.Value = res
	}
	if value, ok := (*data)["visibility"]; ok {
		v.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ElementaryTypeName node

type ElementaryTypeName struct {
	Common
	Name             string           `json:"name"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (e *ElementaryTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":             e.Name,
		"TypeDescriptions": e.TypeDescriptions,
	}
}

func (e *ElementaryTypeName) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		value := value.(map[string]interface{})
		var res TypeDescriptions
		res.Constructor(&value)
		e.TypeDescriptions = res
	}
}

// ----------------------------------------------------------------------------
// VariableDeclarationStatement node

type VariableDeclarationStatement struct {
	Common
	Assignments   []int                 `json:"assignments"`
	Declarrations []VariableDeclaration `json:"declarations"`
	InitialValue  *Common               `json:"initialValue"`
}

func (v *VariableDeclarationStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Assignments":   v.Assignments,
		"Declarrations": v.Declarrations,
		"InitialValue":  v.InitialValue,
	}
}

func (v *VariableDeclarationStatement) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["assignments"]; ok {
		v.Assignments = value.([]int)
	}
	if value, ok := (*data)["declarations"]; ok {
		v.Declarrations = value.([]VariableDeclaration)
	}
	if value, ok := (*data)["initialValue"]; ok {
		v.InitialValue = value.(*Common)
	}
}

// ----------------------------------------------------------------------------
// FunctionCall node
type FunctionCall struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	Arguments        []Common         `json:"arguments"`
	Expression       *Common          `json:"expression"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	Kind             string           `json:"kind"`
	LValueRequested  bool             `json:"lValueRequested"`
	Names            []string         `json:"names"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (f *FunctionCall) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    f.ArgumentTypes,
		"Arguments":        f.Arguments,
		"Expression":       f.Expression,
		"IsConstant":       f.IsConstant,
		"IsLValue":         f.IsLValue,
		"IsPure":           f.IsPure,
		"Kind":             f.Kind,
		"LValueRequested":  f.LValueRequested,
		"Names":            f.Names,
		"TypeDescriptions": f.TypeDescriptions,
	}
}

func (f *FunctionCall) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		f.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["arguments"]; ok {
		f.Arguments = value.([]Common)
	}
	if value, ok := (*data)["expression"]; ok {
		f.Expression = value.(*Common)
	}
	if value, ok := (*data)["isConstant"]; ok {
		f.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		f.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		f.IsPure = value.(bool)
	}
	if value, ok := (*data)["kind"]; ok {
		f.Kind = value.(string)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		f.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["names"]; ok {
		f.Names = value.([]string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		f.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// ExpressionStatement node
type ExpressionStatement struct {
	Common
	Expression *Common `json:"expression"`
}

func (e *ExpressionStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Expression": e.Expression,
	}
}

func (e *ExpressionStatement) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["expression"]; ok {
		e.Expression = value.(*Common)
	}
}

// ----------------------------------------------------------------------------
// FunctionDefinition node
type FunctionDefinition struct {
	Common
	Implemented      bool                 `json:"implemented"`
	IsConstructor    bool                 `json:"isConstructor"`
	IsDeclaredConst  bool                 `json:"isDeclaredConst"`
	Modifiers        []ModifierInvocation `json:"modifiers"`
	Name             string               `json:"name"`
	Parameters       ParameterList        `json:"parameters"`
	Payable          bool                 `json:"payable"`
	ReturnParameters ParameterList        `json:"returnParameters"`
	Scope            int                  `json:"scope"`
	StateMutability  string               `json:"stateMutability"`
	SuperFunction    string               `json:"superFunction"`
	Visibility       string               `json:"visibility"`
}

func (f *FunctionDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Implemented":      f.Implemented,
		"IsConstructor":    f.IsConstructor,
		"IsDeclaredConst":  f.IsDeclaredConst,
		"Modifiers":        f.Modifiers,
		"Name":             f.Name,
		"Parameters":       f.Parameters,
		"Payable":          f.Payable,
		"ReturnParameters": f.ReturnParameters,
		"Scope":            f.Scope,
		"StateMutability":  f.StateMutability,
		"SuperFunction":    f.SuperFunction,
		"Visibility":       f.Visibility,
	}
}

// TODO: Test Modifier is NOT empty
func (f *FunctionDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["implemented"]; ok {
		f.Implemented = value.(bool)
	}
	if value, ok := (*data)["isConstructor"]; ok {
		f.IsConstructor = value.(bool)
	}
	if value, ok := (*data)["isDeclaredConst"]; ok {
		f.IsDeclaredConst = value.(bool)
	}
	if value, ok := (*data)["modifiers"]; ok {
		if len(value.([]interface{})) == 0 {
			f.Modifiers = make([]ModifierInvocation, 0)
		} else {
		}
	}
	if value, ok := (*data)["name"]; ok {
		f.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		f.Parameters = res
	}
	if value, ok := (*data)["payable"]; ok {
		f.Payable = value.(bool)
	}
	if value, ok := (*data)["returnParameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		f.ReturnParameters = res
	}
	if value, ok := (*data)["scope"]; ok {
		res := value.(float64)
		f.Scope = (int)(res)
	}
	if value, ok := (*data)["stateMutability"]; ok {
		f.StateMutability = value.(string)
	}
	if value, ok := (*data)["superFunction"]; ok {
		f.SuperFunction = value.(string)
	}
	if value, ok := (*data)["visibility"]; ok {
		f.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ParameterList node
type ParameterList struct {
	Common
	Parameters []Common `json:"parameters"`
}

func (p *ParameterList) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Parameters": p.Parameters,
	}
}

// TODO: Test the `parameters` is NOT empty
func (p *ParameterList) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["parameters"]; ok {
		if len(value.([]interface{})) == 0 {
			p.Parameters = make([]Common, 0) //WARNING:::CHECK Common, infact it may be Identifier or VariableDeclaration?
		} else {

		}
	}
}

// ----------------------------------------------------------------------------
// EventDefinition node
type EventDefinition struct {
	Common
	Anonymous  bool          `json:"anonymous"`
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
}

func (e *EventDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Anonymous":  e.Anonymous,
		"Name":       e.Name,
		"Parameters": e.Parameters,
	}
}

func (e *EventDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["anonymous"]; ok {
		e.Anonymous = value.(bool)
	}
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		e.Parameters = value.(ParameterList)
	}
}

// ----------------------------------------------------------------------------
// Assignment node
type Assignment struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	LeftHandSide     Common           `json:"leftHandSide"`
	Operator         string           `json:"operator"`
	RightHandSide    Common           `json:"rightHandSide"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (a *Assignment) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    a.ArgumentTypes,
		"IsConstant":       a.IsConstant,
		"IsLValue":         a.IsLValue,
		"IsPure":           a.IsPure,
		"LValueRequested":  a.LValueRequested,
		"LeftHandSide":     a.LeftHandSide,
		"Operator":         a.Operator,
		"RightHandSide":    a.RightHandSide,
		"TypeDescriptions": a.TypeDescriptions,
	}
}

func (a *Assignment) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		a.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		a.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		a.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		a.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		a.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["leftHandSide"]; ok {
		a.LeftHandSide = value.(Common)
	}
	if value, ok := (*data)["operator"]; ok {
		a.Operator = value.(string)
	}
	if value, ok := (*data)["rightHandSide"]; ok {
		a.RightHandSide = value.(Common)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		a.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// MemberAccess node
type MemberAccess struct {
	Common
	ArgumentTypes         []string         `json:"argumentTypes"`
	Expression            Common           `json:"expression"`
	IsConstant            bool             `json:"isConstant"`
	IsLValue              bool             `json:"isLValue"`
	IsPure                bool             `json:"isPure"`
	LValueRequested       bool             `json:"lValueRequested"`
	MemberName            string           `json:"memberName"`
	ReferencedDeclaration int              `json:"referencedDeclaration"`
	TypeDescriptions      TypeDescriptions `json:"typeDescriptions"`
}

func (m *MemberAccess) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":         m.ArgumentTypes,
		"Expression":            m.Expression,
		"IsConstant":            m.IsConstant,
		"IsLValue":              m.IsLValue,
		"IsPure":                m.IsPure,
		"LValueRequested":       m.LValueRequested,
		"MemberName":            m.MemberName,
		"ReferencedDeclaration": m.ReferencedDeclaration,
		"TypeDescriptions":      m.TypeDescriptions,
	}
}

func (m *MemberAccess) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		m.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["expression"]; ok {
		m.Expression = value.(Common)
	}
	if value, ok := (*data)["isConstant"]; ok {
		m.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		m.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		m.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		m.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["memberName"]; ok {
		m.MemberName = value.(string)
	}
	if value, ok := (*data)["referencedDeclaration"]; ok {
		m.ReferencedDeclaration = value.(int)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		m.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// PlacehoderStatement node
type PlacehoderStatement struct {
	Common
}

func (p *PlacehoderStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{}
}

func (p *PlacehoderStatement) Constructor(data *map[string]interface{}) {
}

// ----------------------------------------------------------------------------
// ModifierDefinition node
type ModifierDefinition struct {
	Common
	Name       string        `json:"name"`
	Parameters ParameterList `json:"parameters"`
	Visibility string        `json:"visibility"`
}

func (m *ModifierDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name":       m.Name,
		"Parameters": m.Parameters,
		"Visibility": m.Visibility,
	}
}

func (m *ModifierDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		m.Name = value.(string)
	}
	if value, ok := (*data)["parameters"]; ok {
		value := value.(map[string]interface{})
		var res ParameterList
		res.Constructor(&value)
		m.Parameters = res
	}
	if value, ok := (*data)["visibility"]; ok {
		m.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ElementaryTypeNameExpression node
type ElementaryTypeNameExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	TypeName         string           `json:"typeName"`
}

func (e *ElementaryTypeNameExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    e.ArgumentTypes,
		"IsConstant":       e.IsConstant,
		"IsLValue":         e.IsLValue,
		"IsPure":           e.IsPure,
		"LValueRequested":  e.LValueRequested,
		"TypeDescriptions": e.TypeDescriptions,
		"TypeName":         e.TypeName,
	}
}

func (e *ElementaryTypeNameExpression) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		e.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		e.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		e.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		e.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		e.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		e.TypeDescriptions = value.(TypeDescriptions)
	}
	if value, ok := (*data)["typeName"]; ok {
		e.TypeName = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ModifierInvocation node
type ModifierInvocation struct {
	Common
	Arguments    []Common `json:"arguments"`
	ModifierName Common   `json:"modifierName"`
}

func (m *ModifierInvocation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments":    m.Arguments,
		"ModifierName": m.ModifierName,
	}
}

func (m *ModifierInvocation) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["arguments"]; ok {
		m.Arguments = value.([]Common)
	}
	if value, ok := (*data)["modifierName"]; ok {
		m.ModifierName = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// UserDefinedTypeName node
type UserDefinedTypeName struct {
	Common
	ContractScope        string           `json:"contractScope"`
	ReferenceDeclaration int              `json:"referencedDeclaration"`
	TypeDescriptions     TypeDescriptions `json:"typeDescriptions"`
}

func (u *UserDefinedTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ContractScope":        u.ContractScope,
		"ReferenceDeclaration": u.ReferenceDeclaration,
		"TypeDescriptions":     u.TypeDescriptions,
	}
}

func (u *UserDefinedTypeName) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["contractScope"]; ok {
		u.ContractScope = value.(string)
	}
	if value, ok := (*data)["referencedDeclaration"]; ok {
		u.ReferenceDeclaration = value.(int)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		u.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// InheritanceSpecifier node
type InheritanceSpecifier struct {
	Common
	Arguments []Common `json:"arguments"`
	BaseName  Common   `json:"baseName"`
}

func (i *InheritanceSpecifier) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Arguments": i.Arguments,
		"BaseName":  i.BaseName,
	}
}

func (i *InheritanceSpecifier) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["arguments"]; ok {
		i.Arguments = value.([]Common)
	}
	if value, ok := (*data)["baseName"]; ok {
		i.BaseName = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// UnaryOperation node
type UnaryOperation struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	Operator         string           `json:"operator"`
	Prefix           bool             `json:"prefix"`
	SubExpression    Common           `json:"subExpression"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (u *UnaryOperation) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    u.ArgumentTypes,
		"IsConstant":       u.IsConstant,
		"IsLValue":         u.IsLValue,
		"IsPure":           u.IsPure,
		"LValueRequested":  u.LValueRequested,
		"Operator":         u.Operator,
		"Prefix":           u.Prefix,
		"SubExpression":    u.SubExpression,
		"TypeDescriptions": u.TypeDescriptions,
	}
}

func (u *UnaryOperation) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		u.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		u.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		u.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		u.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		u.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["operator"]; ok {
		u.Operator = value.(string)
	}
	if value, ok := (*data)["prefix"]; ok {
		u.Prefix = value.(bool)
	}
	if value, ok := (*data)["subExpression"]; ok {
		u.SubExpression = value.(Common)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		u.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// Mapping node
type Mapping struct {
	Common
	KeyType          Common           `json:"keyType"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	ValueType        Common           `json:"valueType"`
}

func (m *Mapping) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"KeyType":          m.KeyType,
		"TypeDescriptions": m.TypeDescriptions,
		"ValueType":        m.ValueType,
	}
}

func (m *Mapping) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["keyType"]; ok {
		m.KeyType = value.(Common)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		m.TypeDescriptions = value.(TypeDescriptions)
	}
	if value, ok := (*data)["valueType"]; ok {
		m.ValueType = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// StructDefinition node
type StructDefinition struct {
	Common
	CanonicalName string   `json:"canonicalName"`
	Members       []Common `json:"members"`
	Name          string   `json:"name"`
	Scope         int      `json:"scope"`
	Visibility    string   `json:"visibility"`
}

func (s *StructDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": s.CanonicalName,
		"Members":       s.Members,
		"Name":          s.Name,
		"Scope":         s.Scope,
		"Visibility":    s.Visibility,
	}
}

func (s *StructDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["canonicalName"]; ok {
		s.CanonicalName = value.(string)
	}
	if value, ok := (*data)["members"]; ok {
		s.Members = value.([]Common)
	}
	if value, ok := (*data)["name"]; ok {
		s.Name = value.(string)
	}
	if value, ok := (*data)["scope"]; ok {
		s.Scope = value.(int)
	}
	if value, ok := (*data)["visibility"]; ok {
		s.Visibility = value.(string)
	}
}

// ----------------------------------------------------------------------------
// UsingForDirective node
type UsingForDirective struct {
	Common
	LibraryName Common `json:"libraryName"`
	TypeName    Common `json:"typeName"`
}

func (u *UsingForDirective) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"LibraryName": u.LibraryName,
		"TypeName":    u.TypeName,
	}
}

func (u *UsingForDirective) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["libraryName"]; ok {
		u.LibraryName = value.(Common)
	}
	if value, ok := (*data)["typeName"]; ok {
		u.TypeName = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// IndexAccess node
type IndexAccess struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	BaseExpression   []Common         `json:"baseExpression"`
	IndexExpression  []Common         `json:"indexExpression"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (i *IndexAccess) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    i.ArgumentTypes,
		"BaseExpression":   i.BaseExpression,
		"IndexExpression":  i.IndexExpression,
		"IsConstant":       i.IsConstant,
		"IsLValue":         i.IsLValue,
		"IsPure":           i.IsPure,
		"LValueRequested":  i.LValueRequested,
		"TypeDescriptions": i.TypeDescriptions,
	}
}

func (i *IndexAccess) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		i.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["baseExpression"]; ok {
		i.BaseExpression = value.([]Common)
	}
	if value, ok := (*data)["indexExpression"]; ok {
		i.IndexExpression = value.([]Common)
	}
	if value, ok := (*data)["isConstant"]; ok {
		i.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		i.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		i.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		i.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		i.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// EnumValue node
type EnumValue struct {
	Common
	Name string `json:"name"`
}

func (e *EnumValue) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Name": e.Name,
	}
}

func (e *EnumValue) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
}

// ----------------------------------------------------------------------------
// EnumDefinition node
type EnumDefinition struct {
	Common
	CanonicalName string      `json:"canonicalName"`
	Members       []EnumValue `json:"members"`
	Name          string      `json:"name"`
}

func (e *EnumDefinition) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"CanonicalName": e.CanonicalName,
		"Members":       e.Members,
		"Name":          e.Name,
	}
}

func (e *EnumDefinition) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["canonicalName"]; ok {
		e.CanonicalName = value.(string)
	}
	if value, ok := (*data)["members"]; ok {
		e.Members = value.([]EnumValue)
	}
	if value, ok := (*data)["name"]; ok {
		e.Name = value.(string)
	}
}

// ----------------------------------------------------------------------------
// ArraryTypeName node
type ArraryTypeName struct {
	Common
	BaseType         Common           `json:"baseType"`
	Length           string           `json:"length"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (a *ArraryTypeName) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"BaseType":         a.BaseType,
		"Length":           a.Length,
		"TypeDescriptions": a.TypeDescriptions,
	}
}

func (a *ArraryTypeName) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["baseType"]; ok {
		a.BaseType = value.(Common)
	}
	if value, ok := (*data)["length"]; ok {
		a.Length = value.(string)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		a.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// ForStatement node
type ForStatement struct {
	Common
	Body                     Block           `json:"body"`
	Condition                BinaryOperation `json:"condition"`
	InitializationExpression Common          `json:"initializationExpression"`
	LoopExpression           Common          `json:"loopExpression"`
}

func (f *ForStatement) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"Body":                     f.Body,
		"Condition":                f.Condition,
		"InitializationExpression": f.InitializationExpression,
		"LoopExpression":           f.LoopExpression,
	}
}

func (f *ForStatement) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["body"]; ok {
		f.Body = value.(Block)
	}
	if value, ok := (*data)["condition"]; ok {
		f.Condition = value.(BinaryOperation)
	}
	if value, ok := (*data)["initializationExpression"]; ok {
		f.InitializationExpression = value.(Common)
	}
	if value, ok := (*data)["loopExpression"]; ok {
		f.LoopExpression = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// Break node
type Break struct {
	Common
}

func (b *Break) Attributes() map[string]interface{} {
	return map[string]interface{}{}
}

func (b *Break) Constructor(data *map[string]interface{}) {
}

// ----------------------------------------------------------------------------
// TupleExpression node
type TupleExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	Components       []Common         `json:"components"`
	IsConstant       bool             `json:"isConstant"`
	IsInlineArray    bool             `json:"isInlineArray"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
}

func (t *TupleExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    t.ArgumentTypes,
		"Components":       t.Components,
		"IsConstant":       t.IsConstant,
		"IsInlineArray":    t.IsInlineArray,
		"IsLValue":         t.IsLValue,
		"IsPure":           t.IsPure,
		"LValueRequested":  t.LValueRequested,
		"TypeDescriptions": t.TypeDescriptions,
	}
}

func (t *TupleExpression) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		t.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["components"]; ok {
		t.Components = value.([]Common)
	}
	if value, ok := (*data)["isConstant"]; ok {
		t.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isInlineArray"]; ok {
		t.IsInlineArray = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		t.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		t.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		t.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		t.TypeDescriptions = value.(TypeDescriptions)
	}
}

// ----------------------------------------------------------------------------
// NewExpression node
type NewExpression struct {
	Common
	ArgumentTypes    []string         `json:"argumentTypes"`
	IsConstant       bool             `json:"isConstant"`
	IsLValue         bool             `json:"isLValue"`
	IsPure           bool             `json:"isPure"`
	LValueRequested  bool             `json:"lValueRequested"`
	TypeDescriptions TypeDescriptions `json:"typeDescriptions"`
	TypeName         Common           `json:"typeName"`
}

func (n *NewExpression) Attributes() map[string]interface{} {
	return map[string]interface{}{
		"ArgumentTypes":    n.ArgumentTypes,
		"IsConstant":       n.IsConstant,
		"IsLValue":         n.IsLValue,
		"IsPure":           n.IsPure,
		"LValueRequested":  n.LValueRequested,
		"TypeDescriptions": n.TypeDescriptions,
		"TypeName":         n.TypeName,
	}
}

func (n *NewExpression) Constructor(data *map[string]interface{}) {
	if value, ok := (*data)["argumentTypes"]; ok {
		n.ArgumentTypes = value.([]string)
	}
	if value, ok := (*data)["isConstant"]; ok {
		n.IsConstant = value.(bool)
	}
	if value, ok := (*data)["isLValue"]; ok {
		n.IsLValue = value.(bool)
	}
	if value, ok := (*data)["isPure"]; ok {
		n.IsPure = value.(bool)
	}
	if value, ok := (*data)["lValueRequested"]; ok {
		n.LValueRequested = value.(bool)
	}
	if value, ok := (*data)["typeDescriptions"]; ok {
		n.TypeDescriptions = value.(TypeDescriptions)
	}
	if value, ok := (*data)["typeName"]; ok {
		n.TypeName = value.(Common)
	}
}

// ----------------------------------------------------------------------------
// Helper function to convert a map[string]interface{} to an ASTNode

func StringToASTNode(data map[string]interface{}) (ASTNode, error) {
	//nodeType string, src string, id int

	nodeType, ok := data["nodeType"].(string)
	if !ok || nodeType == "" {
		return nil, fmt.Errorf("nodeType not found")
	}

	src := data["src"].(string)
	if !ok || src == "" {
		return nil, fmt.Errorf("src not found")
	}

	id := int(data["id"].(float64))
	if !ok || id == 0 {
		return nil, fmt.Errorf("id not found or id is 0")
	}

	switch nodeType {
	case "SourceUnit":
		return &SourceUnit{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PragmaDirective":
		return &PragmaDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ContractDefinition":
		return &ContractDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Block":
		return &Block{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Identifier":
		return &Identifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TypeDescriptions":
		return &TypeDescriptions{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "BinaryOperation":
		return &BinaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Literal":
		return &Literal{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IfStatement":
		return &IfStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Return":
		return &Return{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclaration":
		return &VariableDeclaration{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeName":
		return &ElementaryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "VariableDeclarationStatement":
		return &VariableDeclarationStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionCall":
		return &FunctionCall{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ExpressionStatement":
		return &ExpressionStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "FunctionDefinition":
		return &FunctionDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ParameterList":
		return &ParameterList{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EventDefinition":
		return &EventDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Assignment":
		return &Assignment{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "MemberAccess":
		return &MemberAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "PlacehoderStatement":
		return &PlacehoderStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierDefinition":
		return &ModifierDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ElementaryTypeNameExpression":
		return &ElementaryTypeNameExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ModifierInvocation":
		return &ModifierInvocation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UserDefinedTypeName":
		return &UserDefinedTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "InheritanceSpecifier":
		return &InheritanceSpecifier{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UnaryOperation":
		return &UnaryOperation{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Mapping":
		return &Mapping{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "StructDefinition":
		return &StructDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "UsingForDirective":
		return &UsingForDirective{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "IndexAccess":
		return &IndexAccess{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumValue":
		return &EnumValue{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "EnumDefinition":
		return &EnumDefinition{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ArraryTypeName":
		return &ArraryTypeName{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "ForStatement":
		return &ForStatement{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "Break":
		return &Break{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "TupleExpression":
		return &TupleExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil
	case "NewExpression":
		return &NewExpression{
			Common: Common{
				NodeType: nodeType,
				Src:      src,
				ID:       id,
			},
		}, nil

	default:
		return nil, fmt.Errorf("nodeType %s not found", nodeType)
	}
}
